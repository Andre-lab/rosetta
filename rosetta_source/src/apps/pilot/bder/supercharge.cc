// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

/// @file    apps/pilot/bder/supercharge.cc
/// @brief   This protocol supercharges the surface of an input pdb with either positive or negatively charged residues.
/// @details The user must specifiy if Arg, Lys, or Asp, Glu are desired, and what the reference weights are.  This program identifies surface residues, creates a resfile that allows the charged residue and the native amino acid, changes the reference weights of the allowed charged residues, designs the surface (commandline should indicate ex1, ex2, minimize_sidechains), and outputs the designed pose with a name that contains information about the residues allowed and their reference weights for that design run.  Note: In this version, nstruct > 1 will not work because of output naming and calculator registry.
/// @author Bryan Der

#include <devel/init.hh>

#include <core/conformation/Residue.hh>
#include <core/io/pdb/pose_io.hh>
#include <core/kinematics/MoveMap.hh>
#include <core/pack/task/TaskFactory.hh>
#include <core/pack/task/operation/TaskOperations.hh>
#include <core/pose/Pose.hh>
#include <core/pose/PDBInfo.hh>
#include <core/pose/metrics/CalculatorFactory.hh>
#include <core/scoring/ScoreFunction.hh>
#include <core/scoring/ScoreFunctionFactory.hh>

#include <protocols/moves/Mover.hh>
#include <protocols/moves/MinMover.hh>
#include <protocols/moves/PackRotamersMover.hh>
#include <protocols/jd2/JobDistributor.hh>
#include <protocols/toolbox/pose_metric_calculators/NeighborsByDistanceCalculator.hh>

#include <basic/options/util.hh>
#include <basic/options/option.hh>
#include <basic/MetricValue.hh>
#include <basic/Tracer.hh>
#include <utility/exit.hh>
#include <utility/file/FileName.hh>
#include <utility/io/ozstream.hh> // used to create a resfile
#include <sstream>
#include <string>

#include <core/scoring/hbonds/HBondSet.hh>

//tracers
using basic::Error;
using basic::Warning;
using basic::T;
static basic::Tracer TR("apps.pilot.bder.supercharge");

using namespace core;
typedef core::pose::Pose Pose;
typedef std::set< Size > SizeSet;

//local options
namespace local{
basic::options::IntegerOptionKey const neighbor_cutoff("neighbor_cutoff"); //for choosing surface residues
basic::options::BooleanOptionKey const include_arg("include_arg");
basic::options::BooleanOptionKey const include_lys("include_lys");
basic::options::BooleanOptionKey const include_asp("include_asp");
basic::options::BooleanOptionKey const include_glu("include_glu");
basic::options::RealOptionKey const refweight_arg("refweight_arg");
basic::options::RealOptionKey const refweight_lys("refweight_lys");
basic::options::RealOptionKey const refweight_asp("refweight_asp");
basic::options::RealOptionKey const refweight_glu("refweight_glu");
basic::options::BooleanOptionKey const dont_mutate_glyprocys("dont_mutate_glyprocys"); // true by default
basic::options::BooleanOptionKey const dont_mutate_correct_charge("dont_mutate_correct_charge"); // true by default
basic::options::BooleanOptionKey const dont_mutate_hbonded_sidechains("dont_mutate_hbonded_sidechains"); // true by default
basic::options::BooleanOptionKey const pre_minimize_input_structure("pre_minimize_input_structure"); // false by default


}//local


///@brief Improves geometry of zinc-binding matches generated by the Matcher
class supercharge : public protocols::moves::Mover {
public:
  supercharge(){}
  virtual ~supercharge(){};


  virtual
  void
  apply( Pose & pose ) {

		Pose const starting_pose( pose ); //save starting pose to list mutations

		//score pose for hbond detection
		using namespace core::scoring;
		ScoreFunctionOP scorefxn = ScoreFunctionFactory::create_score_function( STANDARD_WTS, SCORE12_PATCH );
		scorefxn->score( pose );

		if(basic::options::option[local::pre_minimize_input_structure]) {
			pre_minimize_input_structure( pose );
		}

		set_surface( pose );
		set_resfile( pose ); // default=NATRO, same-charge=NATAA, allow native+desired charge
		design_supercharge( pose ); // sets reference energies, designs the surface, outputs with an informative name
		print_netcharge_and_mutations(starting_pose, pose );

		return;
  }

	void pre_minimize_input_structure( Pose & pose ) {

		kinematics::MoveMapOP movemap_sc = new kinematics::MoveMap;
		kinematics::MoveMapOP movemap_scbb = new kinematics::MoveMap;
		movemap_sc->set_chi( true );
		movemap_scbb->set_chi( true );
		movemap_scbb->set_bb( true );
		using namespace core::scoring;
		ScoreFunctionOP scorefxn = ScoreFunctionFactory::create_score_function( STANDARD_WTS, SCORE12_PATCH );

		protocols::moves::MinMoverOP min_sc = new protocols::moves::MinMover( movemap_sc, scorefxn, "dfpmin_armijo", 0.01, true );
		protocols::moves::MinMoverOP min_scbb = new protocols::moves::MinMover( movemap_scbb, scorefxn, "dfpmin_armijo", 0.01, true );

		TR << "Minimizing sidechains..." << std::endl;
		min_sc->apply( pose );
		TR << "Minimizing sidechains and backbone..." << std::endl;
		min_scbb->apply( pose );

		return;
	}




	void set_surface( Pose const & pose ){

		// registering the calculators (in this way will not allow nstruct > 1)
		Size biggest_calc(0);
		std::string const calc_stem("nbr_dist_calc_");
		std::ostringstream calcname;
		for(Size res(1); res <= pose.total_residue(); ++res){
			if(biggest_calc < res){ //create calculator
				calcname << calc_stem << res;
				if( pose::metrics::CalculatorFactory::Instance().check_calculator_exists( calcname.str() ) ){
					basic::Warning() << "Calculator " << calcname.str()	<< " already exists, this is hopefully correct for your purposes" << std::endl;
				}
				else {
					pose::metrics::CalculatorFactory::Instance().register_calculator( calcname.str(), new protocols::toolbox::pose_metric_calculators::NeighborsByDistanceCalculator(res) );
				}
				calcname.str("");
				++biggest_calc;
			}
		}
		//find surface residues (number of neighbors cutoff)


		basic::MetricValue< Size > num_n; // number of neighbors
		TR << pose.pdb_info()->name() << std::endl;
		for(Size i(1); i<=pose.total_residue(); ++i){
			calcname << calc_stem << i;
			pose.metric( calcname.str(), "num_neighbors", num_n);
			calcname.str("");

			TR << "residue " << i << " num_neighbors " << num_n.value() << std::endl;

			if( num_n.value() <= core::Size(basic::options::option[local::neighbor_cutoff].value())) {
				TR << "adding " << i << " to surface set" << std::endl;
				surface_res_.insert(i);
			}
		}
		return;
	}


	void set_resfile( Pose const & pose ){
		using namespace basic::options;

		TR << "Creating a resfile, it will be saved as ./resfile_output" << std::endl;
		utility::io::ozstream OutputResfile;
		OutputResfile.open("resfile_output");

		OutputResfile << "NATRO" << std::endl;
		OutputResfile << "start" << std::endl;


		//compute set of hbonds
		core::scoring::hbonds::HBondSet hbond_set;
		hbond_set.setup_for_residue_pair_energies( pose, false, false );

		for(SizeSet::const_iterator it(surface_res_.begin()), end(surface_res_.end()); it!=end; ++it){

			char NATAA_oneletter = pose.residue(*it).name1();

			//gly, pro, and cys are specialized residues that might be better of unchanged
			if( option[local::dont_mutate_glyprocys] ) {
				if(NATAA_oneletter == 'G' || NATAA_oneletter == 'P' || NATAA_oneletter == 'C') {
					continue;
				}
			}

			//if same-charge, leave as NATAA
			if( option[local::dont_mutate_correct_charge] ) {
				if( option[local::include_arg] && NATAA_oneletter == 'R' ) {
					OutputResfile << "   " << pose.pdb_info()->pose2pdb(*it) /*prints resnum and chain*/ << "  NATAA  #same charge" << std::endl;
					continue;
				}
				if( option[local::include_lys] && NATAA_oneletter == 'K' ) {
					OutputResfile << "   " << pose.pdb_info()->pose2pdb(*it) /*prints resnum and chain*/ << "  NATAA  #same charge" << std::endl;
					continue;
				}
				if( option[local::include_asp] && NATAA_oneletter == 'D' ) {
					OutputResfile << "   " << pose.pdb_info()->pose2pdb(*it) /*prints resnum and chain*/ << "  NATAA  #same charge" << std::endl;
					continue;
				}
				if( option[local::include_glu] && NATAA_oneletter == 'E' ) {
					OutputResfile << "   " << pose.pdb_info()->pose2pdb(*it) /*prints resnum and chain*/ << "  NATAA  #same charge" << std::endl;
					continue;
				}
			}

			//preserve strong sidechain hbonds
			if( option[local::dont_mutate_hbonded_sidechains] ) {
				//hbond detection
				bool found_sc_hbond( false );

				for (Size i = 1; i<= hbond_set.nhbonds(); i++) {
					core::scoring::hbonds::HBondCOP hbond(hbond_set.hbond(i));
					if(hbond->energy() > -0.5) { // a fun semi-arbitrary value for hbond strength cutoff
						continue;
					}
					if(hbond->don_res() == *it && !hbond->don_hatm_is_backbone() ) {

						OutputResfile << "   " << pose.pdb_info()->pose2pdb(*it) /*prints resnum and chain*/ << "  NATRO  #has sc hbond energy=" << hbond->energy() << std::endl;

						found_sc_hbond = true;
						break;
					}
					if(hbond->acc_res() == *it && !hbond->acc_atm_is_protein_backbone() ) {
						OutputResfile << "   " << pose.pdb_info()->pose2pdb(*it) /*prints resnum and chain*/ << "  NATRO  #has sc hbond energy=" << hbond->energy() << std::endl;
						found_sc_hbond = true;
						break;
					}
				}
				if( found_sc_hbond ) {
					continue;
				}
			}


			//if there hasn't been a continue, it's a mutable position
			utility::vector1<char> PIKAA_residues;
			PIKAA_residues.push_back(NATAA_oneletter); // the native amino acid is allowed
			if( option[local::include_arg].value() ) {
				PIKAA_residues.push_back('R');
			}
			if( option[local::include_lys].value() ) {
				PIKAA_residues.push_back('K');
			}
			if( option[local::include_asp].value() ) {
				PIKAA_residues.push_back('D');
			}
			if( option[local::include_glu].value() ) {
				PIKAA_residues.push_back('E');
			}

			// print lines in the resfile uch as:  3  A  PIKAA NRK
			OutputResfile << "   " << pose.pdb_info()->pose2pdb(*it) /*prints resnum and chain*/ << "  PIKAA ";
			for(core::Size j(1); j<=PIKAA_residues.size(); ++j){
				OutputResfile << PIKAA_residues[j];
			}
			OutputResfile << std::endl;

		}//iterate over surface residues
		return;
	}


	utility::vector1< Real >
	set_reference_energies(){
		using namespace basic::options;
		utility::vector1< Real > ref_weights;
		ref_weights.push_back(0.16);  //A 1
		ref_weights.push_back(1.7);   //C 2
		ref_weights.push_back( option[local::refweight_asp] ); //D 3 (default=-0.67)
		ref_weights.push_back( option[local::refweight_glu] ); //E 4 (default=-0.81)
		ref_weights.push_back(0.63);  //F 5
		ref_weights.push_back(-0.17); //G 6
		ref_weights.push_back(0.56);  //H 7
		ref_weights.push_back(0.24);  //I 8
		ref_weights.push_back( option[local::refweight_lys] ); //K 9 (default=-0.65)
		ref_weights.push_back(-0.1);  //L 10
		ref_weights.push_back(-0.34); //M 11
		ref_weights.push_back(-0.89); //N 12
		ref_weights.push_back(0.02);  //P 13
		ref_weights.push_back(-0.97); //Q 14
		ref_weights.push_back( option[local::refweight_arg] ); //R 15 (default=-0.98)
		ref_weights.push_back(-0.37); //S 16
		ref_weights.push_back(-0.27); //T 17
		ref_weights.push_back(0.29);  //V 18
		ref_weights.push_back(0.91);  //W 19
		ref_weights.push_back(0.51);  //Y 20
		//0.16 1.7 -0.67 -0.81 0.63 -0.17 0.56 0.24 -0.65 -0.1 -0.34 -0.89 0.02 -0.97 -0.98 -0.37 -0.27 0.29 0.91 0.51

		return ref_weights;
	}

	void
	design_supercharge( Pose & pose ){

		using namespace core::pack::task;
		using namespace basic::options;
		TaskFactoryOP task_factory = new TaskFactory();
		task_factory->push_back(new operation::InitializeFromCommandline()); //ex1, ex1, minimize sidechains, use_input_sc
		task_factory->push_back( new operation::ReadResfile( "resfile_output" ) ); // reads the resfile previously created

		using namespace core::scoring;
		ScoreFunctionOP customref_scorefxn = ScoreFunctionFactory::create_score_function( STANDARD_WTS, SCORE12_PATCH );
		utility::vector1< Real > custom_ref_weights = set_reference_energies(); // SET REFERENCE ENERGIES function
		customref_scorefxn->set_method_weights( ref, custom_ref_weights );
		TR << "Using SCORE12 with custom reference weights\n" << *customref_scorefxn << std::flush;

		protocols::moves::PackRotamersMoverOP packrot_mover = new protocols::moves::PackRotamersMover;
		packrot_mover->score_function( customref_scorefxn );
		packrot_mover->task_factory( task_factory );

		TR << "Supercharging the protein surface..." << std::endl;
		packrot_mover->apply( pose );

		/////////////// rename pdb for output ////////////////////////////////////////

		utility::file::FileName input_pdbname( pose.pdb_info()->name() );
		std::string input_namebase( input_pdbname.base() );
		std::string include_RKDE = "_";
		std::string weights_RKDE = "_";

		if(option[local::include_arg]) {
			include_RKDE = include_RKDE + "R";
			std::string s;
			std::stringstream out;
			out << option[local::refweight_arg];
			s = out.str();
			if(option[local::refweight_arg] > 0.0) { s = "+" + s;	}
			weights_RKDE = weights_RKDE + s + "_";
		}
		if(option[local::include_lys]) {
			include_RKDE = include_RKDE + "K";
			std::string s;
			std::stringstream out;
			out << option[local::refweight_lys];
			s = out.str();
			if(option[local::refweight_lys] > 0.0) { s = "+" + s; }
			weights_RKDE = weights_RKDE + s + "_";
		}
		if(option[local::include_asp]) {
			include_RKDE = include_RKDE + "D";
			std::string s;
			std::stringstream out;
			out << option[local::refweight_asp];
			s = out.str();
			if(option[local::refweight_asp] > 0.0) { s = "+" + s;	}
			weights_RKDE = weights_RKDE + s + "_";
		}
		if(option[local::include_glu]) {
			include_RKDE = include_RKDE + "E";
			std::string s;
			std::stringstream out;
			out << option[local::refweight_glu];
			s = out.str();
			if(option[local::refweight_glu] > 0.0) { s = "+" + s; }
			weights_RKDE = weights_RKDE + s + "_";
		}

		outputname_ = input_namebase + include_RKDE + weights_RKDE + ".pdb";
		TR << "NEW NAME FOR SUPERCHARGED OUTPUT: " << outputname_ << std::endl;

		pose.dump_scored_pdb( outputname_, *customref_scorefxn );

	}

	void
	print_netcharge_and_mutations( Pose const & starting_pose, Pose const & pose ){
		// net charge
		Size num_arg = 0;
		Size num_lys = 0;
		Size num_asp = 0;
		Size num_glu = 0;

		for(Size i=1; i<=pose.total_residue(); i++) {
			if(pose.residue(i).name3() == "ARG")      { num_arg++; }
			else if(pose.residue(i).name3() == "LYS") { num_lys++; }
			else if(pose.residue(i).name3() == "ASP") { num_asp++; }
			else if(pose.residue(i).name3() == "GLU") { num_glu++; }
		}
		int net_charge = num_arg + num_lys - num_asp - num_glu;
		TR << outputname_ << "  R=" << num_arg << ", K=" << num_lys << ", D=" << num_asp << ", E=" << num_glu << std::endl;
		TR << outputname_ << "  Net Charge = " << net_charge << std::endl;

		Size num_mutations = 0;
		std::string pymol_sel_mutations = "select ";
		TR << outputname_ << "  Mutations: ";
		for(Size i=1; i<=pose.total_residue(); i++) {
			//TR << "name1: " << starting_pose.residue(i).name1() << "  " << pose.residue(i).name1() << std::endl;
			if( pose.residue(i).name1() != starting_pose.residue(i).name1() ) {
				num_mutations++;
				Size whitespace = pose.pdb_info()->pose2pdb(i).find(" ");
				std::string resnum_only = pose.pdb_info()->pose2pdb(i).substr(0, whitespace);
				TR << starting_pose.residue(i).name1() << resnum_only << pose.residue(i).name1() << ", ";
				pymol_sel_mutations = pymol_sel_mutations + resnum_only + "+";
			}
		}
		TR << std::endl;
		TR << outputname_ << "  " << pymol_sel_mutations << std::endl;

	}



	virtual
	std::string
	get_name() const { return "supercharge"; }


private:
	SizeSet surface_res_;
	std::string outputname_;

};

typedef utility::pointer::owning_ptr< supercharge > superchargeOP;

int main( int argc, char* argv[] )
{
	using basic::options::option;
	option.add( local::neighbor_cutoff, "cutoff for surface residues ( <= # is surface)" ).def(16);
	option.add( local::include_arg, "include arg in supercharge design").def(false);
	option.add( local::include_lys, "include lys in supercharge design").def(false);
	option.add( local::include_asp, "include asp in supercharge design").def(false);
	option.add( local::include_glu, "include glu in supercharge design").def(false);
	option.add( local::refweight_arg, "reference energy for Arg").def(-0.98);
	option.add( local::refweight_lys, "reference energy for Lys").def(-0.65);
	option.add( local::refweight_asp, "reference energy for Asp").def(-0.67);
	option.add( local::refweight_glu, "reference energy for Glu").def(-0.81);
	option.add( local::dont_mutate_glyprocys, "don't mutate gly, pro, cys").def(true);
	option.add( local::dont_mutate_correct_charge, "don't mutate correct charge").def(true);
	option.add( local::dont_mutate_hbonded_sidechains, "don't mutate hbonded sidechains").def(true);
	option.add( local::pre_minimize_input_structure, "pre-minimize input structure").def(false);

	devel::init(argc, argv);

  protocols::jd2::JobDistributor::get_instance()->go(new supercharge);

  TR << "************************d**o**n**e**************************************" << std::endl;

  return 0;
}

