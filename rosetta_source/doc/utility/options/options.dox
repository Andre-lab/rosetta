// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

/// @file   utility/options/options.dox
/// @brief  Program options system
/// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)


/// @namespace utility::options
///
/// @brief Program options system
///
/// The utility::options package provides a system for representing and accessing
/// the value of program options.  This system is designed to have syntactic and
/// type convenience and to be "pluggable", allowing optional modules to add their
/// own options.  Options are accessed by named keys (see the options::keys package)
/// which provides a high level of type safety and fast lookup.
///
///
/// Introduction
///
/// Options are specified to applications in the usual ways with options entered
/// directly on the command line or in files specified on the command line:
///
///   application -option1 -option2=value2 @file1 -option3 value3 @file2
///
/// Options are accessed within an application's C++ source with a simple syntax.
/// For an options collection named option the lookup is of the form:
///
///   option[ option1 ]
///
/// and this can be used directly as a value of the option's type:
///
///   if ( option[ option1 ] ) ... // Boolean option use
///
/// it is not necessary to specify the option's type in the lookup call.
///
///
/// Option Groups
///
/// Options can be organized into nested groups giving them full names as in:
///
///   application -groupA:option1 -groupA:groupB:option2
///
/// but the options are deduced from the command line context so that short names
/// suffice is almost all usage:
///
///   application -groupA -option1 -groupB -option2
///
/// or simply:
///
///   application -option1 -option2
///
/// if not ambiguous.
///
/// Within the application the option lookup is straightforward.  For an options
/// collection object named option the lookup is of the form:
///
///   option[ option_name ]
///
/// where, for a grouped option, this might look like:
///
///   option[ groupA::groupB::option1 ]
///
/// where the group nesting corresponds to the namespace nesting of the option
/// lookup keys.  Using declarations can be used within the lookup scope to
/// allow shorthand option names to be used:
///
///   using namespace groupA::groupB;
///   ...
///   option[ groupA::groupB::option1 ]
///
///
/// Specifying Options to an Application
///
/// Options are loaded from the command line and/or options files.  Options can
/// be specified in the typical fashion such as  -option=value  where a -- prefix
/// can also be used and whitespace can be used instead of the =.  See the notes
/// below for detailed option specification rules.
///
///
/// Option Names
///
/// Options have full names of the form -top:sub1:sub2:...:bot where the colon
/// separated prefix parts of the name represent the nested group of the option.
/// These full names are seldom needed on the application command line: context
/// deduction is used to find the proper group without the group prefixes.
/// Within the C++ source the options are looked up by keys with names that
/// parallel the command line names of the form top::sub1::sub2::...::bot where
/// the key namespace nesting corresponds to the group nesting.  Options don't
/// have to be organized in nested groups but this is very useful for large
/// option collections.
///
///
/// Option Files
///
/// Options can be read from one or more files by including \@<em>file</em> in the options
/// where <em>file</em> is the name of a file containing one option specification per
/// line, such as:
/// @verbatim
/// # My option file
/// -termini
/// -ab_initio
///  -temperature=3.0 # Note high temperature
/// @endverbatim
///
/// Indented options take the context of the preceding less indented option.
/// In this example the indenting allows us to use a shorthand name for the
/// -ab_initio:temperature  option. See the notes below for detailed \@<em>file</em> rules.
/// Option files can have end-of-line comments following a # character.
///
///
/// Built-in Options
///
/// The -help option will generate a list of the options and their descriptions
/// after which the program will exit.
///
/// The -options:user options will display all of the specified options and their values.
/// The -options:all option will display all of the options and their values.
/// The -options:table:text option will display all of the option definitions
/// in a tab-delimited text table format.
/// The -options:table:Wiki option will display all of the option definitions
/// in a Wiki table format.
/// The -options:exit option causes the program to exit after these displays.
/// If no option display options are specified -options implies -options:user.
///
///
/// Single-Valued Options
///
/// Options that have a single value can appear multiple times in the option
/// specifications to the application: the last value specified is used but if the
/// value is changed by any such overrides a warning is output.
///
///
/// Multi-Valued Options
///
/// Multi-valued options are specified by following the -option with the sequence
/// of whitespace-separated values. Values containing spaces or characters that
/// the shell would treat as having a special meaning should be "quoted".
/// Multi-valued options can also be specified by using multiple -option entries
/// each with one or more values: repeat use of the -option appends to the value
/// list rather than overriding previously specified values.
///
///
/// Initialization
///
/// The options system must be explicity initialized before being loaded: the
/// options are not global objects to avoid initialization order issues.  The
/// initialization can happen in tandem with loading the specified options using
/// this sort of statement near the top of main:
///
/// 	options::initialize().load( argc, argv );
///
///
/// Defining Options
///
/// For each option a key of the correct type must be added to the OptionKeys
/// collection namespace and the option's definition must be added to the Options
/// object in an initialization function (a few "built-in" options are added in
/// the Options constructor).  The option definition includes the key and a
/// description string.  The option can optionally have a default value, a set
/// of legal values, and/or lower and/or upper bounds on the value.  This can be
/// combined into one statement if desired:
///
/// option.add( run::verbosity, "Logging verbosity level" ).lower( 0 ).upper( 9 ).def( 0 );
///
/// The option specification calls are:
/// @verbatim
///   legal( legal_value )		Call once for each legal value
///   lower( lower_value )		Lower limit value: value >= lower_value
///   strict_lower( lower_value )	Strict lower limit value: value > lower_value
///   upper( upper_value )		Upper limit value: value <= upper_value
///   strict_upper( upper_value )	Strict upper limit value: value < upper_value
///   def( default_value )		Default value
/// @endverbatim
///
/// When both legal values and lower and/or upper limits are specified the value
/// need only be either one of the legal values or satisfy the limits.
///
/// The legal, lower, and upper values apply to each element of a multi-valued
/// option.  Multiple defaults can be specified for a multi-valued option by
/// calling def() multiple times or passing it a vector of values.
///
/// Multi-valued options have these additional specification calls:
/// @verbatim
///   n( size )				Required number of values
///   n_lower( lower_size )		Lower limit on number of values
///   n_upper( upper_size )		Upper limit on number of values
/// @endverbatim
///
/// Multiple OptionKeys files in different namespaces can be used to add keys and
/// multiple initialization functions can be used to set up the options.  This
/// provides "pluggability": the set of options can be expanded by optional modules
/// simply by linking them into the application and initializing those options
/// without touching other options related source files.
///
/// A Python script system for automating the option and key C++ sources is
/// provided in options.py, options_class.py, and the sample project options
/// in options_project.py.  The project specific options are encoded in the
/// options_project.py file and then the options.py script is run to generate
/// C++ sources that can be included in option and key definition sources.
///
/// Option Dependencies
///
/// [TO BE ADDED]
///
///
/// Accessing Options in Source Code
///
/// Options are accessed via named keys that are generally defined in OptionKeys
/// namespaces.  Options are typically accessed with the syntax:
///
/// 	option[ key ]
///
/// The options convert to their values where C++ conversion is supported and the
/// value can be explicitly obtained by:
///
///	option[ key ]()       or       option[ key ].value()
///
/// Multi-valued option elements are accessed by index, starting from 1, using
/// eiher (i) or [i] syntax:
///
///	option[ key ]( i )    or       option[ key ][ i ]
///
/// The syntax option[ key ] returns the whole vector (utility::vector1) of
/// values.
///
///
/// Option Types
///
/// A range of common option types is provided along with the ability to add new
/// types as needed.
///
///  @li Boolean options hold a boolean value and can be initialized with a range of
///      typical boolean strings: true, false, On, Off, 1, 0, YES, NO, and so forth.
///      A boolean option with no value specified is set to true (but multi-valued
///      boolean options must specify each value explicitly).
///
///  @li Integer options hold an integer value.
///
///  @li Real options hold a real (double) floating point value.
///
///  @li String options hold a string value.
///
///  @li File options hold a file name object utility::file::FileName that supports paths
///      in Windows and UN*X/Linux format and automatically converts paths to the
///      executing platform format.
///
///  @li Path options hold a file system path name object utility::file::PathName that
///      supports paths in Windows and UN*X/Linux format and automatically converts paths
///      to the executing platform format.
///
///  @li Additional option types can be derived from the AnyOption base class template.
///      These options use the AnyOptionKey key type.  To access these options in their
///      concrete types the syntax:
///
///      	option.option< MyOption >( key )
///
///      must be used: the option[ key ] syntax will return a reference to the abstract
///      Option base class which does not give access to the option's value without a
///      down cast.
///
///
/// @note Option notes:
///
///  @li The -help and -options options are built-in and available with all applications
///
///  @li Options can be specified on a "command line" or an option file (an \@<em>file</em>)
///
///  @li Options are organized in a conceptual tree hierarchy (the implementation data
///      structure does not reflect this hierarchy but the lookup keys do)
///
///  @li Options have full names of the form  top:sub1:sub2:...:bot  where each part
///      of the name is a branch in the option tree
///
///  @li Shorthand option names without some or all of the prefix parts can be used
///      using the preceeding options's context or the indentation structure context
///      of an options file
///
///  @li Full or longer names can always be used to control the option name resolution
///      when the same option short name appears in multiple places in the option hierarchy
///
///  @li Options can be specified with prefix parts that are redundant with their context:
///      -a:b -b:c  will resolve to -a:b:c if it exists
///
///  @li Options can be specified with the form  -:top:...:bot  to force resolution from the
///      top of the hierarchy
///
///  @li Options cannot have numeric name identifiers like 4.4 or 37: these would
///      great command line parsing ambiguities (use of these triggers an error)
///
///  @li Options can be entered with any of the following syntaxes:
///   @verbatim
///       -option=value     or      -:option=value     to specify a top-level context
///      --option=value     or     --:option=value     to specify a top-level context
///       -option value
///       -option value1 value2 ...     for multi-valued options
///   @endverbatim
///
///  @li Option values must be enclosed in "quotes" if they contain spaces or characters
///      that the operating system shell would otherwise treat as having a special meaning
///
///  @li Multi-valued options can also be specified by using multiple -option entries
///      each with one or more values: repeat use of the -option appends to the value
///      list rather than overriding previously specified values
///
/// @note Command line option rules:
///
///  @li Options on the command line are searched for upward within the context of the
///      preceeding option, if any
///
///  @li When an option's specified name could match farther up the option nesting hierarchy
///      a warning about the possible ambiguity is output
///
///  @li Options not found in the upward context search are searched for across all
///      options for a unique suffix match with the most prefix parts matching the
///      context options name, if any, allowing a looser but still safe deduction of
///      option names that are unambiguous for the current option set: these could
///      become ambiguous by options added later in which case the specified options
///      would have to be specified with more suffix parts to eliminate the ambiguity
///
///  @li A command line option following an \@<em>file</em> are resolved in the context
///      of the option preceeding the @file, if any
///
///  @li Only command line arguments following each -option that are of the appropriate
///      type are loaded in the option value(s)
///
///  @li Multi-valued options will take all arguments following their -option that are
///      of the appropriate type until any size limit on the number of values is reached
///
///  @li String, file, and path option values that start with a - or \@ character must
///      be wrapped in single and double quotes as in '"-mystring"' on the command line
///
/// @note Option \@<em>file</em> rules:
///
///  @li Options can be read from a text file by specifying \@<em>file</em> on the
///      command line where <file> is the name of the options file
///
///  @li The options file can be a simple list of option specifications or can use
///      indenting structure to imply the option hierarchy
///
///  @li The first option in the file and unindented options are resolved in the
///      context of the command line preceeding the \@<em>file</em> using the command
///      line rules listed above
///
///  @li Indented options are resolved in the context of the closest prior option
///      in the file with a lower indenting level
///
///  @li Option files can use space or tab indenting, but not both (violations are detected)
///
///  @li Any number of spaces or tabs can be used for each hierarchy level
///
///  @li Blank lines are permitted in an \@<em>file</em>
