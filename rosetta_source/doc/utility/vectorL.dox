// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

/// @file   utility/vectorL.dox
/// @brief  std::vector wrappers with flexible starting index
/// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)


/// @class utility::vectorL
///
/// vectorL is a class template that behaves identically to std::vector except that
/// its elements are indexed from the value of the first template argument up
/// instead of from 0.  vectorL is intended for use in place of std::vector in
/// domains where 0-based indexing isn't natural.
///
/// vectorL is meant to be a container like std::vector but with different element
/// names (indexes).  Taking the container point of view as dominant over the
/// indexing distinction vectorL was written to interoperate with std::vector in a
/// number of ways:
///
/// @li You can (explicitly) construct a vectorL from a std::vector
/// @li You can assign a vectorL from a std::vector
/// @li You can explicitly convert a vectorL to a reference to a std::vector
/// @li You can swap the contents of a vectorL with a std::vector in constant time
/// @li You can compare a vectorL with a std::vector
/// @li Elements are assigned and compared from the beginning of each container to the
///     end, not by corresponding index number.
///
/// vectorL automatically uses a signed index type when the lower index is negative
/// and an unsigned index type otherwise.  This means that when the lower index is
/// negative that maximum possible index is reduced by approximately half due to the
/// range of signed size types.
///
/// @remarks
///
/// The vectorL-based vectors may show a small performance penalty compared with
/// std::vector due to the need to subtract the lower index from the specified index
/// when indexing into the std::vector base object.  In testing this has been found
/// to be minimal when detectable.
///
/// Unlike std::vector the indexing operator[] will check for out of bounds errors
/// in debug builds.
///
/// vector0.fwd.hh and vector1.fwd.hh provide typedefs for common value types.
///
/// vectorL.hh includes vectorL_bool.hh which has the bool specialization (with all
/// the same oddities as std::vector< bool >), and the analogous specializations are
/// provided for vector1 and vector0.
///
/// Use a.swap( b ) or swap( a, b ) or utility::swap( a, b ) to swap two vector1s or
/// a vector1 with a std::vector.  std::swap( a, b ) will work but may be very slow
/// if the std::swap overloads aren't supported on your compiler.
///
/// vectorL inherits from std::vector.  Although std::vector is not designed to
/// serve as a base class this usage is safe because vectorL has no additional data
/// members.
///
/// @note
///  @li std::vector with L-based indexing and a few extras
///  @li Lower index must be in the range of ssize_t
///  @li Index type is std::size_t or ssize_t depending on sign of L
///  @li When L is negative indexing operators can only reach the first max( ssize_t )
///      element and attempting to index beyond that will trigger an assertion failure
///  @li Can construct and assign from std::vector and swap with std::vector
///  @li Can compare with std::vector: compares contents ignoring indexes
///  @li Can explicitly convert to std::vector
///  @li Private inheritance from std::vector is safe here


/// @class utility::vector1
///
/// vector1 is vectorL with the lower index set to 1.
///
/// @note
///  @li std::vector with 1-based indexing and a few extras
///  @li Can construct and assign from std::vector and swap with std::vector
///  @li Can compare with std::vector: compares contents ignoring indexes
///  @li Can explicitly convert to std::vector
///  @li Public inheritance from concrete vectorL template is safe here


/// @class utility::vector0
///
/// vector0 is vectorL with the lower index set to 0.  Since this is the same
/// lower index as std::vector the main purpose for vector0 is to obtain the
/// bounds checking in operator[] in debug builds.
///
/// @note
///  @li std::vector with assert-checked bounds in operator[] and a few extras
///  @li Can construct and assign from std::vector and swap with std::vector
///  @li Can compare with std::vector
///  @li Can explicitly convert to std::vector
///  @li Public inheritance from concrete vectorL template is safe here
