// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
// (C) 199x-2008 University of Washington
// (C) 199x-2008 University of California Santa Cruz
// (C) 199x-2008 University of California San Francisco
// (C) 199x-2008 Johns Hopkins University
// (C) 199x-2008 University of North Carolina, Chapel Hill
// (C) 199x-2008 Vanderbilt University

/*!

@page sqlite3_interface Interface for SQLite3 Database Library

@section metadata Metadata
Last edited 10/18/10.  Code and documentation by Matthew O'Meara mattjomeara@gmail.com.

@section overview Overview

The <a href="http://www.sqlite.org">SQLite3</a> library is simple SQL database engine.  The
Sqlite3Interface class makes SQLite databases from within Rosetta.

@section why_sqlite Why Use a database? Why use SQLite?

Do your csv tables have way to many columns?  Do they not fit into
memory anymore?  Are you protocols turning into multiple phases and
you are having trouble keeping track of which paramters go with which
structure predictions?  Are your runs so long they sometimes die and
your data may be getting corrupted?  Have you hacked together code to
read several tables of parameters? Do you wish you could do "SELECT
... FROM ... WHERE ..." queries over all your data tables?

It may be time to think about using a database.

Data management tasks of different scales require different levels of
sophistication.  Simetimes using a spreadsheet is the right way to go.
Sometimes having several comma separated tables in various directories
is the right way to.  And sometimes using a full fledged SQL database
is the right way to go.

Don't be afraid, SQLite3 is pretty easy to use as far as databases go
and the Sqlite3Interface makes about as easy as writing to a Tracer.

Databases like PostgreSQL or MySQL run as in a client-server server
architecture.  In contrast, SQLite is library linked directly into the
program.  Since each SQLite database is stored in memory or as a
single, they are quite portable and easy to configure.

@section setup_for_sqlite Setup for SQLite

Although SQLite is in the public domain it is not (currently)
distributed with Rosetta.  To prevent it from being global dependency,
Developers using the Sqlite3Interface must specify they intend to use
SQLite at compile time by adding 'sqlite' to the list of 'extra'
options passed to scons.

@verbatim
./scons.py extras=sqlite  <other commands>
@endverbatim

This will instruct gcc to define DB_SQLITE3 as a preprocessing
variable which is used in #ifdef blocks in the code.  Here is simple
example which is fleshed out in the unit test
test/utility/sql_database/Sqlite3Interface.cxxtest.hh.

@verbatim

#ifdef DB_SQLITE
// This requires the external dependency of the sqlite3 library
// To use compile with $scons.py extras=sqlite

#include <utility/sql_database/sqlite3_interface.hh>
using utility::sql_database;


Sqlite3Interface sqlite3_interface("/tmp/test_db.db3");

// A transaction groups together multiple statements to be more
// efficient.
sqlite3_interface.begin_transaction();

sqlite3_interface.execute_sql( "\
TABLE table1 (\
	id INTEGER PRIMARY KEY AUTOINCREMENT,\
	value REAL,\
	math_const TEXT,\
	awesome BOOL );");


sqlite3_interface
	<< Sqlite3Interface::begin_row("table1")
	<< Sqlite3Interface::sqlite3_null
	<< 3.14
	<< "pi"
	<< true
	<< Sqlite3Interface::end_row;

sqlite3_interface.end_transaction();


#endif // DB_SQLITE

@endverbatim

*/       