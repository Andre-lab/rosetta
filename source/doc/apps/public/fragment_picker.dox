
///@author Dominik Gront (dgront@chem.uw.edu.pl)
/*!

@page app_fragment_picker Fragment picking documentation for <code>picker</code> application
 

@section metadata Metadata
Last edited 4/22/11.  Corresponding PI Dominik Gront (dgront@chem.uw.edu.pl).

 

@section code_demos Code and Demo
@li Application source code: <code>rosetta/rosetta_source/src/apps/public/fragment_picker.cc</code>

@li Try-me examples
The examples are located in rosetta/rosetta_demos/fragment_picker directory:
    - BestFragmentsProtocol : basic example demonstrates how to select fragments that maximize a given score function
    - QuotaProtocol : quota protocol demo shows how to pick fragments for an ab-initio protein prediction
    - Quota_with_restraints : demonstrates how to incorporate distance restraints to a fragment picking run

To run picker, type the following in a commandline:
\verbatim
[path to executable]/picker.[platform|linux/mac][compile|gcc/ixx]release â€“database [path to database] @options
\endverbatim

 

@section refs References

The algorithm and the code components have been described in:
@li Gront D, Kulp DW, Vernon RM, Strauss CEM and Baker D, "Generalized fragment picking in Rosetta: design, protocols and applications", submitted to PLoS ONE


@section purpose Purpose
Pick fragment sets for Rosetta protein structure modeling
 

@section algorithm Algorithm
<table><tr>
<td>@image html frag_picker_overview.png "Figure 1: A general scheme of the fragment picking workflow"</td>
<td>Detail of the algorithm are described in Gront D. et al paper. In brief, the program reads a database file (nicknamed <em>vall</em>),
input query sequence or sequence profile and other files and produces fragment files for modeling with Rosetta. The picking process
consists of three stages: preparation (reading input files, etc), actual fragment picking when the candidates are pushed into a collector,
and a selection when the final fragment set is prepared based on the collected candidates.</td>
</tr></table> 

@subsection modes Modes
The picker provides three fragment picking protocols:
@li <b>\ref quota_protocol  "Quota"</b> - substitutes the old <code>nnmake</code> program; selects fragments suitable for de-novo protein structure prediction
@li <b>\ref best_fragments  "Best fragments"</b> - selects fragments by maximizing score function; the protocol works well if available
data (e.g. local backbone NOE, Chemical Shifts, restraints) are satisfactory to define the optimal solution
@li <b>\ref keep_all "Keep all"</b> - may be used to enumerate all the fragments that satisfy some criteria. In general the protocol consumes
a lot of memory and should be used only for very particular applications.

@section inputs Input Files
There are many possible input files, depending on the picking protocol and scoring function. The most commonly used are:

<table>

<tr>
<td><strong>file type</strong></td>
<td><strong>description</strong></td>
<td><strong>where does it come from</strong></td>
<td><strong>who uses it</strong></td>
</tr>


<tr>
<td>vall</td>
<td>protein structures database, your fragments come from there.</td>
<td>should be in Rosetta SVN repository. A copy of this file can be also downloaded from:
http://www.bioshell.pl/rosetta-related/vall.apr24.2008.extended.gz</td>
<td>mandatory file</td>
</tr>

<tr>
<td>.wghts</td>
<td>defines scoring system for fragment selection</td>
<td>edit one of the examples provided below</td>
<td>mandatory file</td>
</tr>

<tr>
<td>.fasta</td>
<td>amino acid sequence</td>
<td>you must already have it...</td>
<td>mandatory file unless .chk is given</td>
</tr>

<tr>
<td>.chk</td>
<td>sequence profile created with PSI-Blast with further modifications (pseudocounts added)</td>
<td>make_fragments.pl script</td>
<td>any sequence profile - based score, e.g. ProfileScoreL1; mandatory file unless .fasta is given</td>
</tr>

<tr>
<td>.ss2</td>
<td>secondary structure prediction in PsiPred format</td>
<td>The easiest way is to run make_fragments.pl script. You may also try to run a secondary prediction software on your own and then convert the resulst to the proper format. A script convert_ss_predictions.py can turn TALOS, Juffo, Porter and SAM into ss2.</td>
<td>SecondarySimilarity or SecondaryIdentity scores</td>
</tr>


<tr>
<td>.cst</td>
<td>distance (or dihedral) constraints</td>
<td>Convert your data (distances or torsion angle values) into the proper format.</td>
<td>AtomPairConstraintsScore or DihedralConstraintsScore scores</td>
</tr>

<tr>
<td>.tab</td>
<td>chemical shifts in TALOS format</td>
<td>NMR experiment; examples can be downloaded from BMRB database</td>
<td>CSScore (CS-Rosetta protocol)</td>
</tr>

<tr>
<td>.pdb</td>
<td>reference structure in PDB format</td>
<td></td>
<td>used for fragments' quality assessment</td>
</tr>
</table>

Note, that some of these files are produced by external programs:
<center>
<table cellspacing=0 cellpadding=0 width=80% class="doxtable">
	<tr>
		<td width=15%>inputa data</td>
		<td width=20%>program</td>
		<td width=65%>notes</td>
	</tr>

	<tr>
		<td width=15%>sequence profile</td>
		<td width=20%>PsiBlast (the old version, not the C++ one!)</td>
		<td width=65%>Raw PsiBlast checkpoint is stored in a binary format. The file is processed by make_fragments.pl script that 
		adds pseudocounts to empty rows in the profile and saves it in a flat text format</td>
	</tr>

	<tr>
		<td width=15%>secondary structure prediciton</td>
		<td width=20%>PsiPred, Jufo, SAM, Porter</td>
		<td width=65%>All these programs require PsiBlast to be installed.fragment_picker reads input secondary structure predicitons
		only in PsiPred's SS2 format. The ss_pred_converter.py script may be used to convert from other file formats</td>
	</tr>
</table>
</center>


@subsection weightfile Weight file for fragment picking

A weight file has at least four columns, which provide: score name, its priority, weight and the maximum allowed value.
If for a certain candidate a given score returned value higher than the maximum allowed, the fragment candidate is no longer considered and any further score won't be evaluated. The scores are evaluated according to the decreasing priority rather than the order how they are listed in a weight file. To be sure that all scores are evaluated for each fragment, put '-' (dash) character as the max_allowed score value. 

Weight value <code>0.0</code> has a special meaning: such scores are evaluated only for the selected fragments, at the end of a program where output files are written. This allows reduce the time spent on fragments descriptive statistics evaluation, such as crmsd or Gunn cost.

Typical weight values are given below:

<table><tr>
<td>@image html frag_scoring_UML.png "Figure 2: UML diagram of the core fragment scoring classes"</td>
<td>For ab-initio prediction (quota protocol):
@code
# score name          priority	wght   max_allowed  extras 
SecondarySimilarity	350	1.0	-	psipred
SecondarySimilarity	300	1.0	-	sam
SecondarySimilarity	250	1.0	-	porter
RamaScore		150	2.0	-	psipred
RamaScore		150	2.0	-	porter
RamaScore		150	2.0	-	sam
ProfileScoreL1      	200	2.0     -
PhiPsiSquareWell	100	0.0	-
FragmentCrmsd        	30 	0.0  	-
@endcode

CS-Rosetta style fragment picking:
@code
# score name          priority	wght   max_allowed  extras 
CSScore                 375     3.0     -
RamaScore		400	2.0	-	talos
SecondarySimilarity	350	3.0	-	talos
ProfileScoreL1      	200	1.0     -
PhiPsiSquareWell	100	0.0	-
FragmentCrmsd        	30 	0.0  	-
GunnCostScore		20	0.0	-
@endcode
</tr></table>
Everything that starts at the fifth column goes to a score term maker as additional parameters. The most important application is to provide secondary structure prediction name for quota protocol.</td>


@section options_picking Options 
@subsection protocol_options Fragment picking options
<center>
<table cellspacing=0 cellpadding=0 width=80% class="doxtable">
	<tr>
		<td width=30%>option</td>
		<td width=60%>description</td>
		<td width=30%>example</td>
	</tr>
	<tr>
		<td width=30%>in:file:native</td>
		<td width=60%>Native PDB filename</td>
		<td width=30%>2gb1.pdb</td>
	</tr>
	<tr>
		<td width=30%>in:file:vall</td>
		<td width=60%>vall database for fragment picking</td>
		<td width=30%>vall.dat.apr24.combo.aug09</td>
	</tr>
	<tr>
		<td width=30%>in:file:s</td>
		<td width=60%>Name(s) of single PDB file(s) to process</td>
		<td width=30%>2gb1.pdb</td>
	</tr>
	<tr>
		<td width=30%>in:file:xyz</td>
		<td width=60%>Input coordinates in a raw XYZ format (three columns)</td>
		<td width=30%>2gb1.xyz</td>
	</tr>
	<tr>
		<td width=30%>in:file:fasta</td>
		<td width=60%>Fasta-formatted sequence file</td>
		<td width=30%>2gb1.fasta</td>
	</tr>
	<tr>
		<td width=30%>in:file:pssm</td>
		<td width=60%>NCBI BLAST formatted position-specific scoring matrix</td>
		<td width=30%>2gb1.pssm</td>
	</tr>
	<tr>
		<td width=30%>in:file:checkpoint</td>
		<td width=60%>Sequence profile (binary file format) prepared by NCBI BLAST</td>
		<td width=30%>2gb1.checkpoint</td>
	</tr>
	<tr>
		<td width=30%>in:file:talos_phi_psi</td>
		<td width=60%>File that provides Phi-Psi angles in Talos+ format</td>
		<td width=30%>2gb1.tab</td>
	</tr>
	<tr>
		<td width=30%>in:file:torsion_bin_probs</td>
		<td width=60%>File describing probabilities over torsion bins A,B,E,G,O</td>
		<td width=30%>2gb1.bin_probs</td>
	</tr>
	<tr>
		<td width=30%>in:path:database</td>
		<td width=60%>Database file input search paths.  If the database is not found the ROSETTA3_DB environment variable is tried.</td>
		<td width=30%></td>
	</tr>
	<tr>
		<td width=30%>frags:scoring:config</td>
		<td width=60%>scoring scheme used for picking fragments</td>
		<td width=30%>quota_scores.wghts</td>
	</tr>
	<tr>
		<td width=30%>frags:scoring:profile_score</td>
		<td width=60%>scoring scheme used for profile-profile comparison</td>
		<td width=30%>L1</td>
	</tr>
	<tr>
		<td width=30%>frags:ss_pred</td>
		<td width=60%>provides one or more files with secondary structure prediction (PsiPred SS2 format) , to be used by secondary structure scoring and quota selector. Each file name must be followed by a string ID.</td>
		<td width=30%>2gb1.psipred_ss2 psipred 2gb1.jufo_ss2 jufo 2gb1.sam_ss2 sam</td>
	</tr>
	<tr>
		<td width=30%>frags:n_frags</td>
		<td width=60%>number of fragments per position</td>
		<td width=30%>200</td>
	</tr>
	<tr>
		<td width=30%>frags:n_candidates</td>
		<td width=60%>number of fragment candidates per position; the final fragments will be selected from them</td>
		<td width=30%>1000</td>
	</tr>
	<tr>
		<td width=30%>frags:frag_sizes</td>
		<td width=60%>sizes of fragments to pick from the vall</td>
		<td width=30%>3 9</td>
	</tr>
	<tr>
		<td width=30%>frags:write_ca_coordinates</td>
		<td width=60%>Fragment picker will store CA Cartesian coordinates in output fragment files. By default only torsion coordinates are stored.</td>
		<td width=30%></td>
	</tr>
	<tr>
		<td width=30%>frags:allowed_pdb</td>
		<td width=60%>provides a text file with allowed PDB chains (five characters per entry, e.g.'4mbA'). Only these PDB chains from Vall will be used to pick fragments</td>
		<td width=30%>templates.pdb_ids</td>
	</tr>
	<tr>
		<td width=30%>frags:denied_pdb</td>
		<td width=60%>provides a text file with denied PDB chains (five characters per entry, e.g.'4mbA'). This way close homologs may be excluded from fragment picking.</td>
		<td width=30%>homologs_vall</td>
	</tr>
	<tr>
		<td width=30%>frags:describe_fragments</td>
		<td width=60%>Writes scores for all fragments into a file</td>
		<td width=30%>frags.fsc</td>
	</tr>
	<tr>
		<td width=30%>frags:keep_all_protocol</td>
		<td width=60%>makes the picker use keep-all protocol to select fragments. The default is bounded protocol</td>
		<td width=30%></td>
	</tr>
	<tr>
		<td width=30%>frags:bounded_protocol</td>
		<td width=60%>makes the picker use bounded protocol to select fragments. This is the default behavior</td>
		<td width=30%></td>
	</tr>
	<tr>
		<td width=30%>frags:quota_protocol</td>
		<td width=60%>quota protocol implies the use of a QuotaCollector and a QuotaSelelctor, no matter what user set up by other flags.</td>
		<td width=30%></td>
	</tr>
	<tr>
		<td width=30%>frags:picking:selecting_rule</td>
		<td width=60%>the way how fragments are selected from candidates, e.g. QuotaSelector of BestTotalScoreSelector</td>
		<td width=30%>BestTotalScoreSelector</td>
	</tr>
	<tr>
		<td width=30%>frags:picking:quota_config_file</td>
		<td width=60%>provides a configuration file for quota selector</td>
		<td width=30%>quota.conf</td>
	</tr>
	<tr>
		<td width=30%>frags:picking:query_pos</td>
		<td width=60%>provide sequence position for which fragments will be picked. By default fragments are picked for the whole query sequence</td>
		<td width=30%>21 22 23 24 25 26 27 28 29</td>
	</tr>
	<tr>
		<td width=30%>constraints:cst_file</td>
		<td width=60%>constraints filename(s) for centoroid. When multiple files are given a *random* one will be picked.</td>
		<td width=30%>2gb1-noe.cst</td>
	</tr>
	<tr>
		<td width=30%>out:file:frag_prefix</td>
		<td width=60%>Prefix for fragment file output</td>
		<td width=30%>aa</td>
	</tr>
</table>
</center>

@section components The fragment picker components and concepts
In brief, the picker process vall database one chunk after another. For each chunk it takes all possible fragment candidates, scores them and stores inside collectors. When all vall chunks are processed, the collectors' content is passed to a selector which selects the final fragments. These are saved into file(s). All parts of this machinery are briefly described below.

@subsection candidate Fragment candidate
... is a fragment-to-be, if it survive the collection and selection stages. 

@subsection collector Fragment collector
The collector collects fragments along with their scores; all the colectors are build on utility::vector1<>. Unfortunately there are more than 2M possible fragment candidates. To keep them all one would need about ... per each residue in a query sequence. Therefore a collector may keep only a small fraction of all candidates. BoundedColelctor keeps Ncand best candidates per each position in a query sequence, where "best" is defined by a comparator object that is used to sort the container.

@subsection selector Fragment selector
Fragment selection rule takes all fragment candidates and selects the final Nfrags fragments. 

@subsection score_caching Cacheable fragment score
Caching is a way to speed up fragment scoring by recycling per-residue score values.
Caching score function must implemant do_caching() method which evaluates a full matrix of 
pairwise residue-vs-residue scores. For instance ProfileL1Score compares any column from query profile
with any profile column from a chunk. When it comes to compute a score of a fragment of length nf that 
start at qi in query and at ci in chunk, a simple sum over a stripe qi->qi+nf; ni -> ni+nf is computed.
Moreover, to evaluate a score for the very next fragment (i.e. the one staring at  (qi+1,ni+1)),  one
can just has to subtract one and add one  per-residue score.

Obviously caching doesn't work when a score cannot be decomposed into per-residue components, e.g. FragmentCrmsd or 
RDCScore. In some cases caching is actually slower than just computing the score without caching, e.g. SequenceIdentity


@subsection quota Quota system
In general the purpose for quota is to keep the diversity within fragments. If for example a given position in a query sequence has been predicted to be helical with 70% chance and loop with 30%, "select best" protocol will pick only helical fragments for this position, because they will be favored by the @c SecondarySimilarity scoring term. To the contrary, quota protocol will pick 30% (best scoring) loop fragments and 70% best scoring helices. The situation is more complicated by the fact that 3 secondary structure predictors are used. This makes in total 9 different categories of fragments (referred further as quota pools) collected and scored separately. Once final fragments are selected (separately for each quota pool), they are merged into a single set.

Quota protocol uses quota specific collectors and selectors. Scoring scheme is also altered.

@subsection quota_pool Quota pools
In quota protocol there are several fragment categories (pools), that are kept separated from each other. They are collected, scored and selected separately. By default there are 3 secondary structure predictions used for fragment picking: PsiPred, SAM and Porter. The fragment candidates are also split by the secondary structure class (H, E or L) which makes 9 quota pools in total. The size of each pool is controlled by quota allowance and secondary structure probability. 

From the implementation's point of view, a quota pool is a BoundedCollector whose size is based on quota allowance, sorted by slightly modified quota score. Note, that quota pools, similarly to fragment collectors, are position specific, so for a 100aa query sequence there are about 900 quota pools.

@subsection quota_def Quota.def file
@code
#pool_id	pool_name	fraction
1		psipred		0.6
2		porter		0.2
3		sam		0.2
@endcode

@subsection quota_allowance Quota allowance
is defined for each predictor by a Quota.def file. Default allocations are: 
PsiPred - 0.6
SAM - 0.2
Porter - 0.2
Final allowance for a quota pool is a product of predictor share and secondary structure probability. For example, if PsiPred predicted that a certain position is helical 

@subsection quota_id Quota score - pool identification
As it has been mentioned in @ref quota_score section, some scores are switched on and off for different pools. To have it working properly, the two config files: @ref weightfile and @ref quota_def must contain matching string identifiers. Although the above examples use the predictors' names (psipred, porter and sam) for this purpose, one can use any arbitrary strings. The only limitation is that the three :
	- secondary prediction name given in a weight file
	- quota pool name, given in Quota.def file
	- econdary prediction name assigned to a RamaScore or SecondarySimilarity score
must match.


@subsection quota_score Quota score
The only difference between the fragment total score and fragment quota score is in the use of proper secondary-structure variant of some scores. Currently this only implies to RamaScore and SecondarySimilarity score. So for example,
a quota pools created from a prediction named "psipred" use <strong>only</strong> SecondarySimilarity score named "psipred". 

	 
@section tips Tips

- multiple fragment sizes: 
@li say <code> -frags:frag_sizes 3 4 5</code> to pick 3-mers, 4-mers and 5-mers

- picking fragments for a predefined region in the query sequence: 
@li say <code> -frags:picking:query_pos 21 22 23 24 25 26 27 28 29 </code> to pick fragments at the selected positions

- test for homologues contamination:
In order to obtain objective results from ab-initio protein structure prediction bechmarks, fragment sets should not contain pieces of homologous proteins. 
The PDB codes of unwanted protein chains should be listed in a file and provided to the picker with -frags:denied_pdb flag. 
This however does not quarantee the results are free from homologous
fragments. It is recommended to check which PDB entries contribute to a fragment, e.g. by the following bash command:
\code
cat aa2gb1.9mers | awk '{print $1}' | uniq | grep -v 'position' | grep '.' | sort | uniq -c | sort -n 
\endcode
Homologues structures introduces significantly more fragments than unrelated proteins. One should manually examine the most popular hits,
possibly add them to the list of denied PDB ids and run the fragment picker once again.

@section outputs Expected Outputs
There are two kinds of output files:

@subsection fragfile fragment file
Output fragments are written in Rosetta++ format.

@subsection scorefile fragment score file
Fragment scores are stored in a flat tabulated format, one score file for each fragment size. All columns from a single line describe a single fragment and provide:
	- its first residue index in a query sequence
	- its first residue index in the source vall chunk
	- PDB id of the source vall chunk
	- chain id of the source vall chunk
	- secondary structure type for the middle residue of the fragment
	- all score values for the whole fragment, ordered by their priority (descending)
	- quota-specific total score for this fragment (only in the case of quota protocol)
	- total (weighted) score for this fragment
	- name of the quota pool who contributed this frgament (only in the case of quota protocol)
	- unique integer ID of this fragment; this is defined as a line number from the vall file where the data for the first residue for this fragment is stored.
		If user provided more than one vall file, continuous numbering is used.

@section postprocess Post Processing

Fragment may be directly used by Rosetta 2.x and 3.x. Fragment score file may be useful for debuging, check for quota levels,
fragment quality assessment, etc.


@section new_stuff New things since last release

    This is the first public release

*/
