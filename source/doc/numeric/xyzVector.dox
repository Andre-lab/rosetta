// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

/// @file   numeric/xyzVector.dox
/// @brief  Fast 3 coordinate ( x, y, z ) vector template class
/// @author Frank M. D'Ippolito (Frank_DIppolito@objexx.com)
/// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)


/// @class numeric::xyzVector
///
/// xyzVector is a fast 3 coordinate ( x, y, z ) vector template class.  Functions are
/// inlined and loop-free for optimal speed.  The destructor is declared non-virtual for
/// speed so xyzVector is not set up for use as a base class.  As a template class,
/// xyzVector can hold various value types.
///
/// Forward declarations and typedefs for common value types are provided in
/// the file xyzVector.fwd.hh.  This header should be included in files that
/// only use the names of the xyzVector types (e.g., function declarations and
/// functions that just pass the types through to other functions by pointer
/// or reference).
///
///
/// Common operations that are normally coded in loops are provided and include:
///
/// normalize()
///
/// normalize_or_zero() - Zero xyzVector if length is zero
///
/// normalize_any() - Arbitrary normalized xyzVector if length is zero
///
/// project_normal() - Project normally onto input xyzVector
///
/// project_parallel() - Project in direction of input xyzVector
///
/// distance() - Distance between two xyzVectors
///
/// distance_squared() - Distance squared between two xyzVectors
///
/// dot(), dot_product(), inner_product() - dot or inner product of two xyzVectors
///
/// cross(), cross_product() - cross product of two xyzVectors
///
/// midpoint() - midpoint between two xyzVectors.
///
/// Many operations also have 'ed' versions; e.g., normalize() and normalized()
/// which do not modify the xyzVector, but generates an xyzVector.
///
/// Additionally, the header xyz_functions.hh contains common functions that interact with
/// xyzVector such as:
///
/// product() - xyzMatrix xyzVector product
///
/// inplace_product() - xyzMatrix xyzVector product, input xyzVector is modified
///
/// outer_product() - xyzVector xyzVector outer product
///
/// projection_matrix() - projection matrix onto the line through an xyzVector
///
/// dihedral() - dihedral (torsion) angle with respect to four positions in a chain
///
/// rotation_matrix() - rotation matrix about a helical axis through the origin through an angle
///
/// rotation_axis() - transformation from rotation matrix to helical axis of rotation
///
/// eigenvalue_jacobi() - classic Jacobi algorithm for the eigenvalues of a real symmetric matrix
///
/// eigenvector_jacobi() - classic Jacobi algorithm for the eigenvalues and eigenvectors of a real symmetric matrix



// Types

/// @typedef numeric::xyzVector::Value
///
/// typedef  T  Value;


// Variables


/// @var numeric::xyzVector::x_
///
/// @brief x coordinate


/// @var numeric::xyzVector::y_
///
/// @brief y coordinate


/// @var numeric::xyzVector::z_
///
/// @brief z coordinate


// Creation


/// @fn numeric::xyzVector::xyzVector()
///
/// @brief Default constructor
/// @note  Values are uninitialized for efficiency


/// @fn numeric::xyzVector::xyzVector( xyzVector const & )
///
/// @brief Copy constructor


/// @fn numeric::xyzVector::xyzVector( xyzVector< U > const & )
///
/// @brief Copy constructor


/// @fn numeric::xyzVector::xyzVector( Value const & )
///
/// @brief Uniform value constructor


/// @fn numeric::xyzVector::xyzVector( Value const &, Value const &, Value const & )
///
/// @brief Triple value constructor


/// @fn numeric::xyzVector::xyzVector( U const * )
///
/// @brief Pointer to contiguous values constructor
/// @note  U must be assignable to a Value
/// @warning Danger! No way to check that argument points to three values
/// @warning Danger! Argument missing an & operator will quietly call the uniform value constructor


/// @fn numeric::xyzVector::~xyzVector()
///
/// @brief Destructor



// Creation: special constructors


/// @fn numeric::xyzVector::negated( ) const
///
/// @brief Negated copy


/// @fn numeric::xyzVector::normalized( ) const
///
/// @brief Normalized copy


/// @fn numeric::xyzVector::normalized_or_zero( ) const
///
/// @brief Normalized copy: Zero xyzVector if length is zero


/// @fn numeric::xyzVector::normalized_any( ) const
///
/// @brief Normalized copy: Arbitrary normalized xyzVector if length is zero


/// @fn numeric::xyzVector::projected_normal( xyzVector const & ) const
///
/// @brief Projected normal copy
/// @note  Copy of this vector projected normally onto input vector
/// @note  Not meaningful when v == 0


/// @fn numeric::xyzVector::projected_parallel( xyzVector const & ) const
///
/// @brief Projected parallel copy
/// @note  Copy of this vector projected in direction of input vector
/// @note  Not meaningful when v == 0



// Methods: assignment


/// @fn numeric::xyzVector::operator =( xyzVector const & )
///
/// @brief Copy assignment
///
/// @param[in] v      xyzVector to assign to the xyzVector
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator =( xyzVector< U > const & )
///
/// @brief Copy assignment
///
/// @param[in] v      xyzVector to assign to the xyzVector
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator =( U const * )
///
/// @brief Assignment from pointer to contiguous values
/// @warning Danger! No way to check that argument points to three values
///
/// @param[in] p      pointer to first of three contiguous values
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator +=( xyzVector< U > const & )
///
/// @brief += xyzVector
///
/// @param[in] v      xyzVector to add to the xyzVector
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator -=( xyzVector< U > const & )
///
/// @brief -= xyzVector
///
/// @param[in] v      xyzVector to subtract from the xyzVector
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator =( Value const & )
///
/// @brief = Value
///
/// @param[in] t      scalar to assign to each coordinate
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator +=( Value const & )
///
/// @brief += Value
///
/// @param[in] t      scalar to add to each coordinate
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator -=( Value const & )
///
/// @brief -= Value
///
/// @param[in] t      scalar to subtract from each coordinate
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator *=( Value const & )
///
/// @brief *= Value
///
/// @param[in] t      scalar by which to multiply each coordinate of the xyzVector
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::operator /=( Value const & )
///
/// @brief /= Value
///
/// @param[in] t      scalar by which to divide each coordinate of the xyzVector
///
/// @return           Reference to the xyzVector


/// @fn numeric::xyzVector::assign( Value const &, Value const &, Value const & )
///
/// @brief Triple value assignment
///
/// @param[in] x_a    x-coordinate
/// @param[in] y_a    y-coordinate
/// @param[in] z_a    z-coordinate
///
/// @return           Reference to the xyzVector



// Methods: complex mathematical


/// @fn numeric::xyzVector::negate()
///
/// @brief Negate
///
/// @return          Additive inverse of the (modified) xyzVector


/// @fn numeric::xyzVector::negated( xyzVector & ) const
///
/// @param[out] a    Additive inverse of the (unmodified) xyzVector
///
/// @brief Negated
///
/// @return          None


/// @fn numeric::xyzVector::normalize()
///
/// @brief Normalize
///
/// @return          The (modified) xyzVector, normalized


/// @fn numeric::xyzVector::normalized( xyzVector & ) const
///
/// @param[out] a    The (unmodified) xyzVector, normalized
///
/// @brief Normalized
///
/// @return          None


/// @fn numeric::xyzVector::normalize_or_zero()
///
/// @brief Normalize: zero xyzVector, if length is zero
///
/// @return          The (modified) xyzVector, normalized; zero xyzVector, if length is zero


/// @fn numeric::xyzVector::normalized_or_zero( xyzVector & ) const
///
/// @param[out] a    The (unmodified) xyzVector, normalized; zero xyzVector, if length is zero
///
/// @brief Normalized: zero xyzVector, if length is zero
///
/// @return          None


/// @fn numeric::xyzVector::normalize_any()
///
/// @brief Normalize: arbitrary normalized xyzVector, if length is zero
///
/// @return          The (modified) xyzVector, normalized; arbitrary normalized xyzVector, if length is zero


/// @fn numeric::xyzVector::normalized_any( xyzVector & ) const
///
/// @param[out] a    The (unmodified) xyzVector, normalized; arbitrary normalized xyzVector, if length is zero
///
/// @brief Normalized: arbitrary normalized xyzVector, if length is zero
///
/// @return          None


/// @fn numeric::xyzVector::project_normal( xyzVector const & )
///
/// @param[in] v     Input xyzVector upon which this xyzVector is projected normally
///
/// @brief Project normal
/// @note  This vector projected normally onto input vector v
/// @note  Not meaningful when v == 0
///
/// @return          The (modified) xyzVector, projected normally onto v


/// @fn numeric::xyzVector::projected_normal( xyzVector const &, xyzVector & ) const
///
/// @param[in] v     Input xyzVector upon which this xyzVector is projected normally
/// @param[out] a    The (unmodified) xyzVector, projected normally onto the input xyzVector v
///
/// @brief Projected normal
/// @note  Copy of this vector projected normally onto v
/// @note  Not meaningful when v == 0
///
/// @return          None


/// @fn numeric::xyzVector::project_parallel( xyzVector const & )
///
/// @param[in] v     Input xyzVector in the direction of which this xyzVector is projected
///
/// @brief Project parallel
/// @note  This vector projected in direction of input vector v
/// @note  Not meaningful when v == 0
///
/// @return          The (modified) xyzVector, in the direction of v


/// @fn numeric::xyzVector::projected_parallel( xyzVector const &, xyzVector & )
///
/// @param[in] v     Input xyzVector in the direction of which this xyzVector is projected
/// @param[out] a    The (unmodified) xyzVector, projected in the direction of the input xyzVector v
///
/// @brief Projected parallel
/// @note  Copy of this vector projected in direction of input vector v
/// @note  Not meaningful when v == 0
///
/// @return          None



// Examples

/// @example
///
/// <ol>
/// <li>
/// To use the xyzVector types in a function you would normally put a using
/// declaration at the top of the function and then use the short typedef
/// name to declare the objects:
///
/// <pre>
/// void
/// f()
/// {
///   using numeric::xyzVector_double;
///
///   xyzVector_double r; // Default constructed (uninitialized)
///   xyzVector_double s( 0.0 ); // Constructs s = ( 0.0, 0.0, 0.0 )
///   xyzVector_double t( 1.0, 2.0, 3.0 ); // Constructs t = ( 1.0, 2.0, 3.0 )
///
///   ...
///   t.x() = 1.5; // Elements can be accessed as x(), y(), and z()
/// }
/// </pre>
/// </li>
///
///
/// <li>
/// You can also construct a numeric::xyzVector from the address of the
/// first value in a contiguous data structure like an FArray or std::vector:
///
/// <pre>
///   xyzVector_double const pos_ij( &position(1,i,j) ); // position(1-3,i,j)
/// </pre>
///
/// You can use numeric::xyzVector in loops by accessing the elements by index:
///
/// <pre>
///   v( i ); // For i = 1, 2, 3   (1-based indexing for xyzVector )
///   v[ i ]; // For i = 0, 1, 2   (0-based indexing for xyzVector )
/// </pre>
/// </li>
/// </ol>
