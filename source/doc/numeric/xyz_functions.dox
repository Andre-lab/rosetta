// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

/// @file   numeric/xyz_functions.dox
/// @brief  xyzVector and xyzMatrix functions
/// @author Frank M. D'Ippolito (Frank_Dippolito@objexx.com)
/// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)
///
/// The header xyz_functions.hh contains common functions that involve both
/// xyzVector and xyzMatrix.


/// @fn numeric::operator *( xyzMatrix< T > const & m, xyzVector< T > const & v )
///
/// @param[in] m      Input xyzMatrix
/// @param[in] v      Input xyzVector
///
/// @brief xyzMatrix * xyzVector
/// @note  Same as product( xyzMatrix, xyzVector )
///
/// @return           m * v (generates an xyzVector)


/// @fn numeric::product( xyzMatrix< T > const & m, xyzVector< T > const & v )
///
/// @param[in] m      Input xyzMatrix
/// @param[in] v      Input xyzVector
///
/// @brief xyzMatrix xyzVector product
/// @note  Same as xyzMatrix * xyzVector
///
/// @return           m * v (generates an xyzVector)


/// @fn numeric::inplace_product( xyzMatrix< T > const & m, xyzVector< T > & v )
///
/// @param[in] m      Input xyzMatrix
/// @param[in,out] v  Input xyzVector to be modified
///
/// @brief xyzMatrix xyzVector in-place product
/// @note  Input xyzVector is modified
///
/// @return           m * v (modifies the input xyzVector)


/// @fn numeric::outer_product( xyzVector< T > const & a, xyzVector< T > const & b )
///
/// @param[in] a      Input xyzVector
/// @param[in] b      Input xyzVector to be modified
///
/// @brief xyzVector xyzVector outer product
///
/// @return           Outer product of a and b ( a * b^T ) (generates an xyzMatrix)


/// @fn numeric::projection_matrix( xyzVector< T > const & v )
///
/// @param[in] v      Input xyzVector
///
/// @brief Projection matrix onto the line through a vector
///
/// @return           Projection matrix onto the line through v (generates an xyzMatrix)


/// @fn numeric::dihedral( xyzVector< T > const & p1, xyzVector< T > const & p2, xyzVector< T > const & p3, xyzVector< T > const & p4, T & angle )
///
/// @param[in] p1     First position in a chain
/// @param[in] p2     second position in a chain
/// @param[in] p3     Third position in a chain
/// @param[in] p4     Fourth position in a chain
/// @param[out] angle Dihedral angle
///
/// @brief Dihedral (torsion) angle: angle value passed
/// @note  Given four positions in a chain ( p1, p2, p3, p4 ), calculates the dihedral
///   (torsion) angle in degrees between the vectors p2->p1 and p3->p4 while sighting
///   along the axis defined by the vector p2->p3 (positive indicates right handed twist).
/// @note  Degenerate cases are handled and assigned a zero angle but assumed rare
///   (wrt performance tuning).
/// @note For a reference on the determination of the dihedral angle formula see:
///   http://www.math.fsu.edu/~quine/IntroMathBio_04/torsion_pdb/torsion_pdb.pdf
///
/// @return           None


/// @fn numeric::dihedral( xyzVector< T > const & p1, xyzVector< T > const & p2, xyzVector< T > const & p3, xyzVector< T > const & p4 )
///
/// @param[in] p1     First position in a chain
/// @param[in] p2     second position in a chain
/// @param[in] p3     Third position in a chain
/// @param[in] p4     Fourth position in a chain
///
/// @brief Dihedral (torsion) angle: angle value returned
/// @note  Given four positions in a chain ( p1, p2, p3, p4 ), calculates the dihedral
///   (torsion) angle in degrees between the vectors p2->p1 and p3->p4 while sighting
///   along the axis defined by the vector p2->p3 (positive indicates right handed twist).
/// @note  Degenerate cases are handled and assigned a zero angle but assumed rare
///   (wrt performance tuning).
/// @note For a reference on the determination of the dihedral angle formula see:
///   http://www.math.fsu.edu/~quine/IntroMathBio_04/torsion_pdb/torsion_pdb.pdf
///
/// @return           Dihedral angle


/// @fn numeric::rotation_matrix( xyzVector< T > const & axis, T const & theta )
///
/// @param[in] axis   Helical axis
/// @param[in] theta  Angle of rotation
///
/// @brief Rotation matrix about a helical axis through the origin through an angle
///
/// @return           Rotation matrix about axis through the angle theta (generates an xyzMatrix)


/// @fn numeric::rotation_axis( xyzMatrix< T > const & R, T & theta )
///
/// @param[in]  R     Input xyzMatrix
/// @param[out] theta Angle of rotation
///
/// @brief Transformation from rotation matrix to helical axis of rotation
/// @note  Input matrix must be orthogonal
/// @note  Angle of rotation is also returned.
/// @note  Orientation of axis chosen so that the angle of rotation is non-negative [0,pi]
/// @remarks
///   If the rotation matrix was created with double theta = pi, rotation_axis does
///   not produce sign errors in the axis elements (likely because pi is truncated
///   to a second quadrant angle and off-diagonal elements of R are in accordance
///   with the axis element signs).
///
///   However, using float precision, the main equations of rotation_axis (if clause)
///   break (give sign errors in the axis elements) when theta = 0.99999999*pi, thereby
///   requiring the special method of the second else clause.
///   If the rotation matrix was created with double precision, near zero angles
///   rotation_axis starts to become inaccurate at theta = 1e-6 (cos_theta = 1-5.0e-13),
///   is very inaccurate at theta = 1e-7, and breaks (axis elements cannot be recovered)
///   at theta = 1e-8.
///
///   With float precision, near zero angles, rotation _axis starts to become inaccurate
///   at theta = 1e-2 (cos_theta = 1-5.0e-5), is very inaccurate at theta = 1e-3,
///   and breaks (axis elements cannot be recovered) at theta = 1e-8.
///   These cases are handled separately by the first else clause.
///
/// @return           Axis of rotation (generates an xyzVector)


/// @fn numeric::eigenvalue_jacobi( xyzMatrix< T > const & a, T const & tol )
///
/// @param[in] a      Input xyzMatrix
/// @param[in] tol    Tolerance for termination of Jacobi iterations
///
/// @brief Classic Jacobi algorithm for the eigenvalues of a real symmetric matrix
/// @note  Use eigenvector_jacobi if eigenvectors are also desired
///
/// @return           Eigenvalues of a (generates an xyzVector)


/// @fn numeric::eigenvector_jacobi( xyzMatrix< T > const & a, T const & tol, xyzMatrix< T > & J )
///
/// @param[in] a      Input xyzMatrix
/// @param[in] tol    Tolerance for termination of Jacobi iterations
/// @param[out] J     Output xyzMatrix of eigenvectors of input xyzMatrix a
///
/// @brief Classic Jacobi algorithm for the eigenvalues and eigenvectors of a
///   real symmetric matrix
/// @note  Use eigenvalue_jacobi if eigenvectors are not desired
///
/// @return           Eigenvalues of a (generates an xyzVector)


/// @fn numeric::jacobi_rotation( xyzMatrix< T > const & m, int i, int j, xyzMatrix< T > & r )
///
/// @param[in] m      Input xyzMatrix
/// @param[in] i      Row index of element to zero out
/// @param[in] j      Column index of element to zero out
/// @param[out] r     Orthogonal transformation used by eigenvalue_jacobi and eigenvector_jacobi
///                   to zero out the (i,j) and (j,i) elements of input xyzMatrix m
///
/// @brief Jacobi rotation
/// @note  Compute the orthogonal transformation used to zero out a pair of
///   off-diagonal elements
///
/// @return           None
