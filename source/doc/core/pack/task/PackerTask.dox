// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.

///@author Steven Lewis
/*!

@page Packer_Task How to use the PackerTask

This page describes how the PackerTask (actually the PackerTask_, because the former is an interface class) is intended to be used.  Andrew LF built it so that it would be "commutative": the order in which you alter the PackerTask has no effect on its ultimate state (this is like a state function in thermodynamics).  As a corollary, you are not allowed to arbitrarily modify the PackerTask; you can alter it generally only through commutative setters.  Also, much of the real information in the PackerTask is contained within its ResidueLevelTasks (ResidueLevelTask_), which allows position-level control of behavior.  Most of this documentation applies to either; a call to the_task.residue_task(resid) returns the ResidueLevelTask you want.

@section commutativity Commutativity

There are two types of commutativity: "and" + "or".  and commutativity means that a behavior will be true if and only if all inputs are consistently true, it means:

 - state = (input1 && input2 && input3 && input4)

This is used for behaviors that default to being turned "on", and will therefore stay on until they are explicitly turned off.  The notable PackerTask behaviors here are the packability and designability of residues, which both start on, as well as the residue types list, which starts with all canonicals (both his tautomers; not disulfides) allowed at all positions.

The other type of commutativity is or, which functions as:

 - state = (input1 || input2 || input3 || input4)

This is used for behaviors which default "off" and must be turned on.  Notable examples include anything related to rotamers and inclusion of noncanonical amino acids.

@section using_PackerTask How to make calls changing the PackerTask

The PackerTask_ documentation (PackerTask is an interface class) contains the documentation for individual functions.  Typically, calls to functions that start with or_ will be an or-commutative behavior; calls that start with and (or those like restrict_to_repacking or prevent_repacking) will have and-commutative behavior, and calls that are not obviously either are probably get functions.

@section chaining_PackerTask How to chain calls

PackerTask calls that modify the task usually return the task.  This allows you to chain calls together:
@code
the_task.initialize_from_command_line().read_resfile();
@endcode
This will cause the PackerTask to have all its member data set to match the commutative "solution" to the behaviors defined by the command line and resfile.

*/
