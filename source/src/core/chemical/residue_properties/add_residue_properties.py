#!/usr/bin/env python
# :noTabs=true:
# (c) Copyright Rosetta Commons Member Institutions.
# (c) This file is part of the Rosetta software suite and is made available
# (c) under license.
# (c) The Rosetta software is developed by the contributing members of the
# (c) Rosetta Commons.
# (c) For more information, see http://www.rosettacommons.org.
# (c) Questions about this can be addressed to University of Washington UW
# (c) TechTransfer, email: license@u.washington.edu.

"""File: src/core/chemical/residue_properties/add_residue_properties.py

Brief: This PyRosetta script auto-generates C++ code for ResiduePropertys.

Note: (Yes, I meant ResiduePropertys and not ResidueProperties.)

Details: To add a new property to Rosetta for use in .params files, patch
files, and ResidueTypes, simply add a string to the general_properties.list
file and run this script.

(You may also consider adding new is_ accessors to ResidueType and Residue.)

Params: none, yet

Example: ./add_residue_properties.py

Remarks: Blah blah blah, blah, blah.

Author: Jason W. Labonte

"""

# Imports

# Constants
PROPERTIES_FILE = 'general_properties.list'  # TODO: Allow for multiple files?
HEADER_FILE = 'ResidueProperty.hh'
SOURCE_FILE = 'property_mappings.cc'

HEADER = [
    '// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-\n',
    '// vi: set ts=2 noet:\n',
    '//\n',
    '// (c) Copyright Rosetta Commons Member Institutions.\n',
    '// (c) This file is part of the Rosetta software suite and is made available under license.\n'
    '// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.\n',
    '// (c) For more information, see http://www.rosettacommons.org. Questions about this can be\n',
    '// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.\n',
    "\n"]


def read_enum_values_from_file(filename):
    """Return each line of a file to a list."""
    lines = []
    with open(filename) as f:
        for line in f:
            if not line.startswith("#") and line != "\n":
                lines.append(line)
    return lines

def generate_ResidueProperty_header_file():
    """Write the ResidueProperty.hh file, using enum values read from a file."""
    lines = []

    # Add the header.
    lines.extend(HEADER)

    # Add the Doxygen info.
    lines.append('/// @file    core/chemical/' + HEADER_FILE + "\n")
    lines.append('/// @brief   Enumeration definition for ResidueProperty.\n')
    lines.append('/// @author  Labonte <JWLabonte@jhu.edu>\n')
    lines.append('/// @note    DO NOT EDIT THIS FILE DIRECTLY!  It is auto-generated.\n')
    lines.append('/// If you wish to edit it, modify the add_residue_properties.py script.\n')
    lines.append("\n")

    # Add the header guard.
    lines.append('#ifndef INCLUDED_core_chemical_ResidueProperty_HH\n')
    lines.append('#define INCLUDED_core_chemical_ResidueProperty_HH\n')
    lines.append("\n")

    # Add the namespacing.
    lines.append('namespace core {\n')
    lines.append('namespace chemical {\n')
    lines.append("\n")

    # Add the comments and the enum declaration.
    lines.append('// If adding new residue properties, DO NOT MANUALLY EDIT THIS ENUMERATOR DEFINITION.\n')
    lines.append('// Instead, add your property to the general_properties.list, and run the add_residue_properties.py script.\n')
    lines.append('/// @brief  Enumerators for all the properties that can be assigned to a ResidueType.\n')
    lines.append('enum ResidueProperty {\n')

    # Define the enumeration values.
    lines.append('\tFIRST_PROPERTY = 1,\n')

    first_property = property_data[0].split("#")[0].strip()
    final_property = property_data[-1].split("#")[0].strip()

    for data in property_data:
        split_data = data.split("#")
        property = split_data[0].strip()
        comment = ''
        if len(split_data) > 1:
            comment = split_data[1].rstrip()
        line = "\t" + property
        if property != first_property:
            line += ","
        else:
            line += ' = 1,'
        if comment:
            line += '  //' + comment
        line += "\n"
        lines.append(line)

    lines.append('\tN_RESIDUE_PROPERTIES = ' + final_property + "\n")
    lines.append('};\n')
    lines.append("\n")

    # Close the namespacing and header guard.
    lines.append('}  // namespace chemical\n')
    lines.append('}  // namespace core\n')
    lines.append("\n")
    lines.append('#endif  // INCLUDED_core_chemical_ResidueProperty_HH\n')

    # write lines to file.
    with open('../' + HEADER_FILE, "w") as f:
        f.writelines(lines)

    print 'Successfully generated ' + HEADER_FILE + "."


def generate_mappings_source_file():
    """Write the property_mappings.cc file, using enum values read from a file."""
    lines = []

    # Add the header.
    lines.extend(HEADER)

    # Add the Doxygen info.
    lines.append('/// @file    core/chemical/' + SOURCE_FILE + "\n")
    lines.append('/// @brief   Method definitions for two private static methods declared in ResidueProperties.hh.\n')
    lines.append('/// @author  Labonte <JWLabonte@jhu.edu>\n')
    lines.append('/// @note    DO NOT EDIT THIS FILE DIRECTLY!  It is auto-generated.\n')
    lines.append('/// If you wish to edit it, modify the add_residue_properties.py script.\n')
    lines.append('/// It is because it is auto-generated that these class methods are not defined in ResidueProperties.cc.\n')
    lines.append("\n")

    # Add the #includes.
    lines.append('// Unit header\n')
    lines.append('#include <core/chemical/ResidueProperties.hh>\n')
    lines.append("\n")
    lines.append('// Utility header\n')
    lines.append('#include <utility/vector1.hh>\n')
    lines.append("\n")
    lines.append('// C++ headers\n')
    lines.append('#include <map>\n')
    lines.append("\n")

    # Add the namespacing.
    lines.append('namespace core {\n')
    lines.append('namespace chemical {\n')
    lines.append("\n")

    # Add "using namespace".
    lines.append('using namespace core;\n')
    lines.append("\n")

    # Add the first method.
    # Add the comments and function signature.
    lines.append('// Get the ResidueProperty enum value from the corresponding sting.\n')
    lines.append('// This private static class method is declared in ResidueProperties.hh.\n')
    lines.append('// If adding new residue properties, DO NOT MANUALLY EDIT THIS FUNCTION DEFINITION.\n')
    lines.append('// Instead, add your property to the database, and run the add_residue_properties.py script.\n')
    lines.append('ResidueProperty const &\n')
    lines.append('ResidueProperties::get_property_from_string( std::string const & property )\n')

    # Define the function.
    lines.append('{\n')
    lines.append('\tusing namespace std;\n')
    lines.append("\n")
    lines.append('\t// This line is only executed once.\n')
    lines.append('\tstatic map< string, ResidueProperty > * PROPERTY_MAP = NULL;\n')
    lines.append("\n")
    lines.append('\t// If statement ensures that the data is only created once, i.e., is constant.\n')
    lines.append('\tif ( ! PROPERTY_MAP ) {\n')
    lines.append('\t\t// A map of ResidueProperty enum values keyed by corresponding string.\n')
    lines.append('\t\tPROPERTY_MAP = new map< string, ResidueProperty >;\n')
    lines.append("\n")

    for data in property_data:
        property = data.split("#")[0].strip()
        line = '\t\tPROPERTY_MAP->insert( make_pair( "'
        line += property.rstrip() + '", ' + property.rstrip() + ' ) );\n'
        lines.append(line)

    lines.append('\t}\n')
    lines.append("\n")
    lines.append('\treturn ( *PROPERTY_MAP )[ property ];\n')
    lines.append('}\n')
    lines.append("\n")

    # Add the second method.
    # Add the comments and function signature.
    lines.append('// Get a string from the corresponding ResidueProperty enum value.\n')
    lines.append('// This private static class method is declared in ResidueProperties.hh.\n')
    lines.append('// If adding new residue properties, DO NOT MANUALLY EDIT THIS FUNCTION DEFINITION.\n')
    lines.append('// Instead, add your property to the database, and run the add_residue_properties.py script.\n')
    lines.append('std::string const &\n')
    lines.append('ResidueProperties::get_string_from_property( ResidueProperty const property )\n')

    # Define the function.
    lines.append('{\n')
    lines.append('\tusing namespace std;\n')
    lines.append('\tusing namespace utility;\n')
    lines.append("\n")
    lines.append('\t// This line is only executed once.\n')
    lines.append('\tstatic vector1< string > * STRING_LIST = NULL;\n')
    lines.append("\n")
    lines.append('\t// If statement ensures that the data is only created once, i.e., is constant.\n')
    lines.append('\tif ( ! STRING_LIST ) {\n')
    lines.append('\t\t// A vector mapping ResidueProperty enum values to their corresponding strings.\n')
    lines.append('\t\tSTRING_LIST = new vector1< string >;\n')
    lines.append('\t\tSTRING_LIST->resize( N_RESIDUE_PROPERTIES, "" );\n')
    lines.append("\n")

    for data in property_data:
        property = data.split("#")[0].strip()
        line = '\t\t( *STRING_LIST )[ '
        line += property.rstrip() + ' ] = "' + property.rstrip() + '";\n'
        lines.append(line)

    lines.append('\t}\n')
    lines.append("\n")
    lines.append('\treturn ( *STRING_LIST )[ property ];\n')
    lines.append('}\n')
    lines.append("\n")

    # Close the namespacing.
    lines.append('}  // namespace chemical\n')
    lines.append('}  // namespace core\n')

    # write lines to file.
    with open('../' + SOURCE_FILE, "w") as f:
        f.writelines(lines)

    print 'Successfully generated ' + SOURCE_FILE + "."


# Main
property_data = read_enum_values_from_file(PROPERTIES_FILE)
generate_ResidueProperty_header_file()
generate_mappings_source_file()

