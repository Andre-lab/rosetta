#!/usr/bin/env python
# :noTabs=true:
# (c) Copyright Rosetta Commons Member Institutions.
# (c) This file is part of the Rosetta software suite and is made available
# (c) under license.
# (c) The Rosetta software is developed by the contributing members of the
# (c) Rosetta Commons.
# (c) For more information, see http://www.rosettacommons.org.
# (c) Questions about this can be addressed to University of Washington UW
# (c) TechTransfer, email: license@u.washington.edu.

"""File: src/core/chemical/residue_properties/add_residue_properties.py

Brief: This PyRosetta script auto-generates C++ code for ResiduePropertys.

Note: (Yes, I meant ResiduePropertys and not ResidueProperties.)

Details: To add a new property to Rosetta for use in .params files, patch
files, and ResidueTypes, simply add a string to the general_properties.list
file and run this script.

(You may also consider adding new is_ accessors to ResidueType and Residue.)

Params: none, yet

Example: ./add_residue_properties.py

Remarks: Blah blah blah, blah, blah.

Author: Jason W. Labonte

"""

# Imports
from os.path import isfile

# Constants
PROPERTIES_FILE = 'general_properties.list'  # TODO: Allow for multiple files?
HEADER_FILE = 'ResidueProperty.hh'
SOURCE_FILE = 'property_mappings.cc'

HEADER = [
    '// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-\n',
    '// vi: set ts=2 noet:\n',
    '//\n',
    '// (c) Copyright Rosetta Commons Member Institutions.\n',
    '// (c) This file is part of the Rosetta software suite and is made available under license.\n',
    '// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.\n',
    '// (c) For more information, see http://www.rosettacommons.org. Questions about this can be\n',
    '// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.\n',
    "\n"]
AUTHOR_AND_NOTE = [
    '/// @author  Labonte <JWLabonte@jhu.edu>\n',
    '/// @note    DO NOT EDIT THIS FILE DIRECTLY!  It is auto-generated.\n',
    '/// If you wish to edit it, modify the add_residue_properties.py script.\n']
NAMESPACE_OPENING = [
    'namespace core {\n',
    'namespace chemical {\n',
    "\n"]
NAMESPACE_CLOSING = [
    '}  // namespace chemical\n',
    '}  // namespace core\n']


def read_lines_from_file(filename):
    """Return each line of a file to a list."""
    lines = []
    f = open(filename)
    try:
        for line in f:
            if not line.startswith("#") and line != "\n":
                lines.append(line)
    finally:
        f.close()
    return lines


def separate_properties_from_comments(lines_to_parse):
    """Parse each line by searching for a # symbol and return two lists."""
    properties = []
    comments = []
    already_used_properties = []

    for line in lines_to_parse:
        split_data = line.split("#")
        property = split_data[0].strip()

        # Check for duplicated properties.
        if property in already_used_properties:
            print 'WARNING: The residue property', property, 'is found in',
            print PROPERTIES_FILE, 'twice!  Ignoring...'
            continue
        already_used_properties.append(property)

        comment = ''
        if len(split_data) > 1:
            comment = split_data[1].rstrip()

        properties.append(property)
        comments.append(comment)
    return properties, comments


def write_lines_to_file_if_necessary(lines, filename):
    """Compare the existing file with the proposed new file and only write the
    new file with different.

    Return True if a new file has been written.

    """
    if isfile('../' + filename):
        f = open('../' + filename, "r")
        try:
            existing_lines = f.readlines()
        finally:
            f.close()
        if lines == existing_lines:
            return False

    f = open('../' + filename, "w")
    try:
        f.writelines(lines)
    finally:
        f.close()
    print 'Successfully generated ' + filename + "."
    return True


def generate_ResidueProperty_header_file(properties, comments):
    """Write the ResidueProperty.hh file from lists of properties and their
    corresponding comments, if the data have changed.

    Return True if a new file has been written.

    """
    lines = []

    # Add the header.
    lines.extend(HEADER)

    # Add the Doxygen info.
    lines.append('/// @file    core/chemical/' + HEADER_FILE + "\n")
    lines.append('/// @brief   Enumeration definition for ResidueProperty.\n')
    lines.extend(AUTHOR_AND_NOTE)
    lines.append("\n")


    # Add the header guard.
    lines.append('#ifndef INCLUDED_core_chemical_ResidueProperty_HH\n')
    lines.append('#define INCLUDED_core_chemical_ResidueProperty_HH\n')
    lines.append("\n")

    # Add the namespacing.
    lines.extend(NAMESPACE_OPENING)

    # Add the comments and the enum declaration.
    lines.append('// If adding new residue properties, DO NOT MANUALLY EDIT THIS ENUMERATOR DEFINITION.\n')
    lines.append('// Instead, add your property to the general_properties.list, and run the add_residue_properties.py script.\n')
    lines.append('/// @brief  Enumerators for all the properties that can be assigned to a ResidueType.\n')
    lines.append('enum ResidueProperty {\n')

    # Define the enumeration values.
    lines.append('\tFIRST_PROPERTY = 1,\n')

    for property, comment in zip(properties, comments):
        line = "\t" + property
        if property != properties[0]:  # if not the 1st property...
            line += ","
        else:
            line += ' = 1,'
        if comment:
            line += '  //' + comment
        line += "\n"
        lines.append(line)

    # Include a enum value for the number of properties.
    lines.append('\tN_RESIDUE_PROPERTIES = ' + properties[-1] + "\n")
    lines.append('};\n')
    lines.append("\n")

    # Close the namespacing and header guard.
    lines.extend(NAMESPACE_CLOSING)
    lines.append("\n")
    lines.append('#endif  // INCLUDED_core_chemical_ResidueProperty_HH\n')

    return write_lines_to_file_if_necessary(lines, HEADER_FILE)


def generate_mappings_source_file(properties):
    """Write the property_mappings.cc file from a list of properties, if the
    data have changed.

    Return True if a new file has been written.

    """
    lines = []

    # Add the header.
    lines.extend(HEADER)

    # Add the Doxygen info.
    lines.append('/// @file    core/chemical/' + SOURCE_FILE + "\n")
    lines.append('/// @brief   Method definitions for two private static methods declared in ResidueProperties.hh.\n')
    lines.extend(AUTHOR_AND_NOTE)
    lines.append('/// It is because it is auto-generated that these class methods are not defined in ResidueProperties.cc.\n')
    lines.append("\n")

    # Add the #includes.
    lines.append('// Unit header\n')
    lines.append('#include <core/chemical/ResidueProperties.hh>\n')
    lines.append("\n")
    lines.append('// Utility header\n')
    lines.append('#include <utility/vector1.hh>\n')
    lines.append("\n")
    lines.append('// C++ headers\n')
    lines.append('#include <map>\n')
    lines.append("\n")

    # Add the namespacing.
    lines.extend(NAMESPACE_OPENING)

    # Add "using namespace".
    lines.append('using namespace core;\n')
    lines.append("\n")

    # Add the first method.
    # Add the comments and function signature.
    lines.append('// Get the ResidueProperty enum value from the corresponding sting.\n')
    lines.append('// This private static class method is declared in ResidueProperties.hh.\n')
    lines.append('// If adding new residue properties, DO NOT MANUALLY EDIT THIS FUNCTION DEFINITION.\n')
    lines.append('// Instead, add your property to the database, and run the add_residue_properties.py script.\n')
    lines.append('ResidueProperty const &\n')
    lines.append('ResidueProperties::get_property_from_string( std::string const & property )\n')

    # Define the function.
    lines.append('{\n')
    lines.append('\tusing namespace std;\n')
    lines.append("\n")
    lines.append('\t// This line is only executed once.\n')
    lines.append('\tstatic map< string, ResidueProperty > * PROPERTY_MAP = NULL;\n')
    lines.append("\n")
    lines.append('\t// If statement ensures that the data is only created once, i.e., is constant.\n')
    lines.append('\tif ( ! PROPERTY_MAP ) {\n')
    lines.append('\t\t// A map of ResidueProperty enum values keyed by corresponding string.\n')
    lines.append('\t\tPROPERTY_MAP = new map< string, ResidueProperty >;\n')
    lines.append("\n")

    for property in properties:
        line = '\t\tPROPERTY_MAP->insert( make_pair( "'
        line += property + '", ' + property + ' ) );\n'
        lines.append(line)

    lines.append('\t}\n')
    lines.append("\n")
    lines.append('\treturn ( *PROPERTY_MAP )[ property ];\n')
    lines.append('}\n')
    lines.append("\n")

    # Add the second method.
    # Add the comments and function signature.
    lines.append('// Get a string from the corresponding ResidueProperty enum value.\n')
    lines.append('// This private static class method is declared in ResidueProperties.hh.\n')
    lines.append('// If adding new residue properties, DO NOT MANUALLY EDIT THIS FUNCTION DEFINITION.\n')
    lines.append('// Instead, add your property to the database, and run the add_residue_properties.py script.\n')
    lines.append('std::string const &\n')
    lines.append('ResidueProperties::get_string_from_property( ResidueProperty const property )\n')

    # Define the function.
    lines.append('{\n')
    lines.append('\tusing namespace std;\n')
    lines.append('\tusing namespace utility;\n')
    lines.append("\n")
    lines.append('\t// This line is only executed once.\n')
    lines.append('\tstatic vector1< string > * STRING_LIST = NULL;\n')
    lines.append("\n")
    lines.append('\t// If statement ensures that the data is only created once, i.e., is constant.\n')
    lines.append('\tif ( ! STRING_LIST ) {\n')
    lines.append('\t\t// A vector mapping ResidueProperty enum values to their corresponding strings.\n')
    lines.append('\t\tSTRING_LIST = new vector1< string >;\n')
    lines.append('\t\tSTRING_LIST->resize( N_RESIDUE_PROPERTIES, "" );\n')
    lines.append("\n")

    for property in properties:
        line = '\t\t( *STRING_LIST )[ '
        line += property + ' ] = "' + property + '";\n'
        lines.append(line)

    lines.append('\t}\n')
    lines.append("\n")
    lines.append('\treturn ( *STRING_LIST )[ property ];\n')
    lines.append('}\n')
    lines.append("\n")

    # Close the namespacing.
    lines.extend(NAMESPACE_CLOSING)

    return write_lines_to_file_if_necessary(lines, SOURCE_FILE)


# Main
property_data = read_lines_from_file(PROPERTIES_FILE)
properties, comments = separate_properties_from_comments(property_data)

enum_updated = generate_ResidueProperty_header_file(properties, comments)
mappings_updated = generate_mappings_source_file(properties)

print 'Finished updating ResidueType properties',
if not enum_updated and not mappings_updated:
    print ' -- no changes needed'

