#!/usr/bin/env python
#
# (c) Copyright Rosetta Commons Member Institutions.
# (c) This file is part of the Rosetta software suite and is made available under license.
# (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
# (c) For more information, see http://www.rosettacommons.org. Questions about this can be
# (c) addressed to University of Washington CoMotion, email: license@uw.edu.

## @file   pymol_colab_server.py
## @brief  PyMOL Mover server for Google Colab
## @author Sergey Lyskov

import socket, threading, socketserver, random, string, hashlib, sys
import select as select_module, socket as socket_module, time as time_module, os as os_module
from argparse import ArgumentParser

# specify secret string (password) to use when connecting to relay
# you will need to use the secret sting in both this script and in rosetta_udp_to_tcp_bridge scripts
# if left blank ask user interactivly on each run
# good `secret` line could be generated by running: python3 -c 'import random, string; print( "".join( random.sample( string.ascii_letters + string.digits, 32 ) ) )'
_my_secret_ = None

_my_secret_ = _my_secret_ if _my_secret_ else os_module.getenv('ROSETTA_PYMOL_SECRET')

_default_relay_server_, _default_relay_port_ = 'relay.graylab.jhu.edu', 9989



import math
import time
import socket
import gzip
import bz2
import threading
from array import array

from io import BytesIO


from queue import Queue, Empty, Full

_packet_queue_maximum_size = 8

packet_queue = Queue( maxsize = _packet_queue_maximum_size )


class StartUpError(Exception):
    """Exception class for server start-up failures."""
    def __str__(self):
        return "FAILED TO START PyRosetta-PyMOL server." + \
               "\nDo you already have another instance of it running?"


# Other classes.
class PR_UDPServer:
    def __init__(self, udp_ip='127.0.0.1', udp_port=65000):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            self.socket.bind((udp_ip, udp_port))
        except:
            raise StartUpError()
        self.buf = {}
        self.last_cleanup_time = time.time()

    def listen(self):
        data, addr = self.socket.recvfrom(1024 * 64)  # 64k buffer
        #print 'Got Message from %s' % str(addr), len(data)

        packet_id = data[:(16 + 2)]
        counts = array('H', data[18:22])  # should be 2 short integers

        #print 'Packet count info:', counts
        if counts[1] == 1:  # only one messgage in pack...
            return array('B', data[22:])  #bz2.decompress(data[22:])
        else:
            if packet_id not in self.buf:
                self.buf[packet_id] = [0., {}]

            c, d = self.buf[packet_id]
            d[counts[0]] = data[22:]
            self.buf[packet_id][0] = time.time()

            # Now, let's check if we can find all the pieces of the message....
            if len(d) == counts[1]:  # Yes, they are all here....
                #print 'Assembling message from %s pieces....' % counts[1]
                m = array('B')
                for i in range(counts[1]):
                    m.extend(array('B', d[i]))
                del self.buf[packet_id]

                #print 'Message is:', len(m), m, d
                #print 'Leftover buffer len:', len(self.buf)
                return m  #bz2.decompress(m)

            else:
                # There are no ready-to-return packets...; However, let's check
                # if the buffer can be cleaned up....
                # Anything older than 10 seconds should be discarded....
                current_time = time.time()
                if current_time - self.last_cleanup_time > 2.:
                    # Cleaning up every 2 s
                    for k in list( self.buf.keys() ):
                        if current_time - self.buf[k][0] > 10.0:
                            print( 'Buffer clean up: %s' % repr(k) )
                            del self.buf[k]

                return None


def udp_main(ip, port):
    print( f'UDP server started: {ip}:{port}...' )

    udp_serv = PR_UDPServer(ip, port)
    #PS = PR_PyMOLServer()
    while True:
        r = udp_serv.listen()
        if r:
            #print( f'adding packet with len={len(r)} to queued...' )
            #PS.process_packet(r)
            if packet_queue.full():
                try:
                    o = packet_queue.get_nowait()
                    #print(f'discarding packet with len: {len(o)}...')
                except Empty: pass

            packet_queue.put(r)

    s.close()


def start_udp_server(ip='', port=65000):
   if not ip:
       ip = socket.gethostbyname(socket.gethostname())
       if ip == '127.0.0.1':
           print("Unable to automatically determine your IP address. ", end='')
           print("Please specify it manually. ", end='')
           print("e.g., start_rosetta_server 192.168.0.1")
           return

   thread = threading.Thread(target=udp_main, args=[ip, port])
   thread.setDaemon(1)
   thread.start()



def tcp_main(relay_address, relay_port, secret):
    ip, port = socket_module.gethostbyname(relay_address), relay_port

    #print(f'Initiating connection to {relay_address} {ip}:{port}...')

    h = hashlib.sha256()
    h.update( bytes(secret, 'utf-8') )

    secret = h.digest()

    while True:
        with socket_module.socket(socket_module.AF_INET, socket_module.SOCK_STREAM) as S:
            S.settimeout(10)

            try:
                S.connect( (ip, port) )
                print(f'Connected to {relay_address} {ip}:{port}...')
                S.sendall(secret)
                S.sendall( bytes('w', 'ascii') )

                while True:
                    try:
                        packet = packet_queue.get(timeout=8)

                    except Empty:
                        packet = b''

                    length = len(packet).to_bytes(4, 'little')

                    #print(f'Sending lentgh:{len(packet)}, data:{packet[:16]}...')

                    S.sendall(length)
                    S.sendall(packet)


            except (ConnectionRefusedError, ConnectionResetError, TimeoutError, BrokenPipeError, OSError):
               S.close()
               print(f'trying to reconnect to {ip}:{port}...')
               time_module.sleep(5)



def start_udp_to_tcp_bridge_daemon(secret, relay_address=_default_relay_server_, relay_port=_default_relay_port_):
    print(f'WARNING: CONNECTION to relay server {relay_address}:{relay_port} IS NOT ENCRYPTED!')

    start_udp_server('localhost')

    thread = threading.Thread(target=tcp_main, args=[relay_address, relay_port, secret])
    thread.setDaemon(1)
    thread.start()



def main(args):
    parser = ArgumentParser(description=main.__doc__)

    parser.add_argument('-v', '--verbose', action="store_true", default=False, help="Enable verbose output, off by default." )

    parser.add_argument('--port', action="store", default=_default_relay_port_, help="specify TCP port to use" )

    parser.add_argument('-a', '--address', default=_default_relay_server_, action="store", help="specify relay server address")

    parser.add_argument('secret', default=_my_secret_, help="specify secret to use")

    options = parser.parse_args()


    start_udp_to_tcp_bridge_daemon( secret = options.secret, relay_address = options.address, relay_port = options.port)

    time.sleep(99999999)


if __name__ == "__main__": main(sys.argv)
