// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
// vi: set ts=2 noet:
//
// (c) Copyright Rosetta Commons Member Institutions.
// (c) This file is part of the Rosetta software suite and is made available under license.
// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
// (c) addressed to University of Washington CoMotion, email: license@uw.edu.

/// @file   ui/task/task.h
/// @brief  Task class for ui library.
/// @author Sergey Lyskov (sergey.lyskov@jhu.edu).

#ifndef TASK_H
#define TASK_H

#include <ui/task/task.fwd.h>

#include <ui/task/node.h>
#include <ui/task/project.h>

#include <ui/util/exception.h>

#include <QObject>
#include <QAbstractTableModel>
//#include <QJsonObject>

#include <ui/task/task_syncer.h>

namespace ui {
namespace task {


/// Generic container that represent abstract chunk of data that will be stored as file on back-end.
/// Derive new classes from it if you need to create new types of Node while re-use serialization routines
class FileMixin
{
public:

	virtual QString type() const = 0;

private:
	virtual QByteArray data() const = 0;
	virtual void data(QByteArray const &) = 0;

	//virtual QByteArray file_data() const = 0;
	//virtual void file_data(QByteArray const &) = 0;

	virtual QString file_name() const = 0;


	// return true if underlying object contain no data
	virtual bool empty() const = 0;
};


/// File node that hold concreate data with concreate file-name
class File : public FileMixin
{
public:
	explicit File() {}
	explicit File(QString const & file_name);
	explicit File(QByteArray const & file_data);
	explicit File(QString const & file_name, QByteArray const & file_data);

	QString type() const override { return "file"; };

	void init_from_file(QString const & file_name);

	// we pulling FileMixin methods into public because they now have double function as accessor to file data
	QByteArray data() const override;
	void data(QByteArray const &_file_data) override;

    //QByteArray file_data() const override { return file_data_; };
	//void file_data(QByteArray const &_file_data) override { file_data_ = _file_data; }

	QString file_name() const override { return file_name_; }
	void file_name(QString const &_file_name) { file_name_ = _file_name; }

	QString hash() const { return hash_; }
	void hash(QString const &_hash) { hash_ = _hash; }

	bool empty() const override { return file_data_.isEmpty(); }
	//bool null() const override { return file_data_.isNull(); }

	File& operator=(File&& other) noexcept;


	bool operator ==(File const &r) const;
	bool operator !=(File const &r) const { return not (*this == r); }

	// serialization
	friend QDataStream &operator<<(QDataStream &, File const&);
	friend QDataStream &operator>>(QDataStream &, File &);

private:
	QString hash_; // hash for file data if any (generated by server)
	QString file_name_; // local file name if any
	QByteArray file_data_;
};

//using Files = std::map<std::string, File>;


class FileTableModel : public QAbstractTableModel
{
	Q_OBJECT
public:
	using QAbstractTableModel::QAbstractTableModel;

	QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const override;

	int rowCount(const QModelIndex &parent = QModelIndex()) const override;
	int	columnCount(const QModelIndex &parent = QModelIndex()) const override;
	Qt::ItemFlags flags(const QModelIndex &index) const override;

	QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const override;
	bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole) override;

	void update_from_task(Task const &task);

Q_SIGNALS:
	void rename_file(QString const &previous_value, QString const &s);

private:
	struct Row {
		QString name, path;
	};

	std::vector<Row> rows_;
	bool editable_ = false;
};


class Task : public QObject
{
	Q_OBJECT

public:
	enum class State {_none_, _draft_, _queued_, _running_, _finished_, _unknown_};

public:
	explicit Task();
	//explicit Task(QString const &description);
	~Task();

	// return current Task State
	State state() const { return state_; }

	// return queue that will be used to run this Task
	QString queue() const { return queue_; }

	// return true if there is any outgoing/pending network operations
	bool is_syncing() const;

	// return <current_value, max_value> for syncing operation progress
	std::pair<int, int> syncing_progress() const;

	QAbstractTableModel * files_model() { return &files_model_; }

	Project *project() const { return project_; }

	//std::map<QString, FileSP> const & output() const { return output_; }

	/// add file to Task files collection
	void add_file(QString const &name, FileSP const &file);
	std::map<QString, FileSP> const & files() const { return files_; }

	/// delete file from task, return true if file was in task files
	bool delete_file(QString const &name);

	// should not be needed, add/remove Tasks should be done on Project level
	// void project(Project *p)  { project_ = p; }

	/// Initiate submit procedure
	void submit(QString const & queue);

	/// return QString representation of task_id (int) if task was already submitted other wise return empty string
	QString task_id() const;

	QString name() const { return name_; }
	void name(QString const &);

	QString app() const { return app_; }
	void app(QString const &);

	QString version() const { return version_; }
	void version(QString const &);

	QString flags() const { return flags_; }
	void flags(QString const &);

	QString description() const { return description_; }
	void description(QString const &);

	int nstruct() const { return nstruct_; }
	void nstruct(int);


	// File const &input() const { return input_; }
	// void input(File &&input) { if( input_ != input ) { input_ = std::move(input);  Q_EMIT changed(); } }
	// File const &script() const { return script_; }
	// void script(File &&script) { if( script_ != script ) { script_ = std::move(script); Q_EMIT changed(); } }
	// File const &flags() const { return flags_; }
	// void flags(File &&flags) { if( flags_ != flags ) { flags_ = std::move(flags); Q_EMIT changed(); } }

	/// subscribe to network update stream
	void subscribe();

	// bool operator ==(Task const &r) const;
	// bool operator !=(Task const &r) const { return not (*this == r); }

	// serialization
	friend QDataStream &operator<<(QDataStream &, Task const&);
	friend QDataStream &operator>>(QDataStream &, Task &);


	static QString to_string(Task::State state);
	static Task::State from_string(QString const &s);

Q_SIGNALS:
	void submitted();

    void changed();

	/// Emitted when node or sub-node syncing state changed
	void syncing();


	/// Emitted once when Task is fully downloaded and no further network operations will be issued
	void final();

private Q_SLOTS:

	void rename_file(QString const &previous_value, QString const &s);

	//void output_topology_updated(Node const *, std::vector<QString> const & new_keys, std::vector<QString> const &  errased_keys);
	//void output_topology_updated(Node const *);


private:

	/// connect nodes and Task structre, assign callback's
	//void connect_task_and_nodes();

	//void output_topology_updated(Node const *, std::vector<QString> const & new_keys, std::vector<QString> const &  errased_keys);

private:
	QJsonValue task_data();
	void task_data(QJsonValue const &);

	// QJsonObject task_data();
	// void task_data(QJsonObject const &);

	// set <current_value, max_value> for syncing operation progress
	void syncing_progress(int value, int max);

	// move progress forward by `value` points
	void syncing_progress_advance(int value);

	/// Some project functions require access to project_
	friend void Project::add_task(TaskSP const &task);
	friend bool Project::erase(TaskSP const &task);
	friend void Project::assign_ownership(TaskSP const &t);

	friend class TaskSyncer_NodeStrategy;
	friend class TaskSyncer_TaskStrategy;
	//friend class TaskUpdateFunctor;

	State state_ = State::_none_;

	QString queue_;

	QString app_, version_, flags_;
	int nstruct_ = 1;

	/// UUID for cloud syncing. Zero id by default (will be set to a new random value on 'submit' event).
	//QUuid task_id_;

	QString name_, description_;

	QVariant task_id_;

	//File input_, script_, flags_;
	//std::map<QString, FileSP> output_;

	std::map<QString, FileSP> files_;

	FileTableModel files_model_;

	//TaskSyncer_NodeStrategy syncer_;
	TaskSyncer_TaskStrategy syncer_;

	//NodeWP input_node_, script_node_, flags_node_;
	//NodeWP output_node_;

	/// root node of network syncing tree
	//NodeSP root_;

	QPointer<Project> project_;

	std::pair<int, int> syncing_progress_ = {0, 0};
};



// class TaskBadFileFormatException : public ui::util::BadFileFormatException
// {
// public:
//     void raise() const { throw *this; }
//     TaskBadFileFormatException *clone() const { return new TaskBadFileFormatException(*this); }
// };


/*
///
/// Interface type for strategy for Task synchronization (options+files)
///
class AbstractTaskSyncer : public QObject
{
public:
	//AbstractTaskSyncer(Task *);

	virtual void submit_task(QString const &queue) = 0;
};

/// TaskSyncer based on `node/` api
class NodeTaskSyncer : public AbstractTaskSyncer
{
		Q_OBJECT
public:
	NodeTaskSyncer(Task *task);

	// using OptionsCallback = std::function< QJsonValue   (void) >;
	// using FilesCallback   = std::function< Files const &(void) >;

	// void options_callback(GetOptionsCallback const &get_options) { get_options_ = get_options; }
	// void files_callback(GetFilesCallback const &get_files) { get_files_ = get_files; }

	void submit_task(QString const &queue) override;

	// serialization
	friend QDataStream &operator<<(QDataStream &, NodeTaskSyncer const&);
	friend QDataStream &operator>>(QDataStream &, NodeTaskSyncer &);


// public: Q_SIGNALS:
//     void options_changed(QJsonValue const &data);
//     void file_changed(QString const &name);

// public Q_SLOTS:
// 	void options_is_fresh();
// 	void files_is_fresh();

private:
	Task *task_;
// 	OptionsCallback options_;
// 	FilesCallback   files_;


};
*/
// TaskSyncer based on `task/` api
//class TaskSyncer : public AbstractTaskSyncer


} // namespace task
} // namespace ui


#endif // TASK_H
